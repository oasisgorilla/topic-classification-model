67
CHAPTER  11    잡다한 기법
받으므로 이미 (void*)형을 사용하더라도 무조건 형변환한다. 
4.	 
temp를 해제할 필요는 없다. 이렇게 작은 메모리 누수의 효과는 
미미하기 때문에 며칠 동안 프로그램을 돌려도 끄떡없는 경우가 많다. 
5.	 
만약을 대비해서 버퍼에서 필요한 데이터 이상을 복사하라. 
유닉스에서는 코어 덤프가 발생할 것이다. 
6.	 
위 코드에서 os는 “old size”를, ns는 “new size”를 의미하는 듯하다. 
7.	 
표준 라이브러리에 이미 있는 간단한 함수는 다시 만든다. 
8.	 
buf를 할당하고 0으로 memset한다. 누군가 ANSI 스펙을 변경할 가능성
이 있으므로 calloc()을 사용하는 것은 위험하다(일단 어차피 buf 크기와 
동일한 데이터를 복사한다는 사실은 신경쓰지 말자). 
사용하지 않은 변수 에러를 고치는 방법 
컴파일러에서 “사용하지 않은 지역 변수” 경고를 발생한다고 해서 그 변수를 꼭 없
앨 필요는 없다. 대신, 창의적으로 고민을 좀 해보자. 나같으면… 
i = i; 
중요한 것은 크기 
함수가 크면 클수록 좋다는 것은 두말하면 잔소리인 진리다. 물론 jump와 GOTO
도 많을수록 좋다. 이렇게 할 때 누군가 무엇을 변경하게 되면, 검증해야 할 시나리
오가 정말 다양해진다. 이제 코드 스스로가 유지보수 프로그래머에게서 자신을 보
호할 수 있게 된다. 함수를 거인 왕처럼 만들 수 있다면 함수는 고질라가 되어 유지
보수 프로그래머가 무슨 일인지 정신을 차리기도 전에 공격하고 무자비하게 밟아
버릴 것이다. 
하나의 그림은 단어 1,000개를 대신하고, 하나의 함수는 행 1,000개를 대신한다 
모든 메소드의 바디를 가능한 한 길게 만들어라. 깊게 중첩하는 것을 잊지 말고 절
대 앞으로는 1,000행 이하의 메소드나 함수를 만드는 일이 없도록 하라. 
