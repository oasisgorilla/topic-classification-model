222
Chapter 3
Machine-Level Representation of Programs
Aside
Comparing byte movement instructions
The following example illustrates how different data movement instructions either do or do not change
the high-order bytes of the destination. Observe that the three byte-movement instructions movb,
movsbq, and movzbq differ from each other in subtle ways. Here is an example:
1
movabsq $0x0011223344556677, %rax
%rax = 0011223344556677
2
movb
$0xAA, %dl
%dl
= AA
3
movb %dl,%al
%rax = 00112233445566AA
4
movsbq %dl,%rax
%rax = FFFFFFFFFFFFFFAA
5
movzbq %dl,%rax
%rax = 00000000000000AA
In the following discussion, we use hexadecimal notation for all of the values. The ﬁrst two lines
of the code initialize registers %rax and %dl to 0011223344556677 and AA, respectively. The remaining
instructions all copy the low-order byte of %rdx to the low-order byte of %rax. The movb instruction
(line 3) does not change the other bytes. The movsbq instruction (line 4) sets the other 7 bytes to
either all ones or all zeros depending on the high-order bit of the source byte. Since hexadecimal A
represents binary value 1010, sign extension causes the higher-order bytes to each be set to FF. The
movzbq instruction (line 5) always sets the other 7 bytes to zero.
Practice Problem 3.3 (solution page 362)
Each of the following lines of code generates an error message when we invoke
the assembler. Explain what is wrong with each line.
movb $0xF, (%ebx)
movl %rax, (%rsp)
movw (%rax),4(%rsp)
movb %al,%sl
movq %rax,$0x123
movl %eax,%rdx
movb %si, 8(%rbp)
3.4.3
Data Movement Example
As an example of code that uses data movement instructions, consider the data
exchange routine shown in Figure 3.7, both as C code and as assembly code
generated by gcc.
As Figure 3.7(b) shows, function exchange is implemented with just three
instructions: two data movements (movq) plus an instruction to return back to
the point from which the function was called (ret). We will cover the details of
function call and return in Section 3.7. Until then, it sufﬁces to say that arguments
are passed to functions in registers. Our annotated assembly code documents
these. A function returns a value by storing it in register %rax, or in one of the
low-order portions of this register.
