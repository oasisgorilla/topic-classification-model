116
Chapter 2
Representing and Manipulating Information
One point worth making is that the relative order of conversion from one
data size to another and between unsigned and signed can affect the behavior of
a program. Consider the following code:
1
short sx = -12345;
/* -12345
*/
2
unsigned uy = sx;
/* Mystery! */
3
4
printf("uy
= %u:\t", uy);
5
show_bytes((byte_pointer) &uy, sizeof(unsigned));
When run on a big-endian machine, this code causes the following output to be
printed:
uy = 4294954951:
ff ff cf c7
This shows that, when converting from short to unsigned, the program ﬁrst
changes the size and then the type. That is, (unsigned) sx is equivalent to
(unsigned) (int) sx, evaluating to 4,294,954,951, not (unsigned) (unsigned
short) sx, which evaluates to 53,191. Indeed, this convention is required by the
C standards.
Practice Problem 2.23 (solution page 186)
Consider the following C functions:
int fun1(unsigned word) {
return (int) ((word << 24) >> 24);
}
int fun2(unsigned word) {
return ((int) word << 24) >> 24;
}
Assume these are executed as a 32-bit program on a machine that uses two’s-
complement arithmetic. Assume also that right shifts of signed values are per-
formed arithmetically, while right shifts of unsigned values are performed logically.
A. Fill in the following table showing the effect of these functions for several
example arguments. You will ﬁnd it more convenient to work with a hexa-
decimal representation. Just remember that hex digits 8 through F have their
most signiﬁcant bits equal to 1.
w
fun1(w)
fun2(w)
0x00000076
0x87654321
0x000000C9
0xEDCBA987
B. Describe in words the useful computation each of these functions performs.
