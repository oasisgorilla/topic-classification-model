510
Chapter 4
Processor Architecture
movq (%rsp), REG
Read REG from stack
addq $8,%rsp
Increment stack pointer
A. In light of analysis done in Practice Problem 4.8, does this code sequence
correctly describe the behavior of the instruction popq %rsp? Explain.
B. How could you rewrite the code sequence so that it correctly describes both
the cases where REG is %rsp as well as any other register?
4.47 ◆◆◆
Your assignment will be to write a Y86-64 program to perform bubblesort. For
reference, the following C function implements bubblesort using array refer-
encing:
1
/* Bubble sort: Array version */
2
void bubble_a(long *data, long count) {
3
long i, last;
4
for (last = count-1; last > 0; last--) {
5
for (i = 0; i < last; i++)
6
if (data[i+1] < data[i]) {
7
/* Swap adjacent elements */
8
long t = data[i+1];
9
data[i+1] = data[i];
10
data[i] = t;
11
}
12
}
13
}
A. Write and test a C version that references the array elements with pointers,
rather than using array indexing.
B. Write and test a Y86-64 program consisting of the function and test code.
You may ﬁnd it useful to pattern your implementation after x86-64 code
generated by compiling your C code. Although pointer comparisons are
normally done using unsigned arithmetic, you can use signed arithmetic for
this exercise.
4.48 ◆◆
Modify the code you wrote for Problem 4.47 to implement the test and swap in
the bubblesort function (lines 6–11) using no jumps and at most three conditional
moves.
4.49 ◆◆◆
Modify the code you wrote for Problem 4.47 to implement the test and swap in the
bubblesort function (lines 6–11) using no jumps and just one conditional move.
4.50 ◆◆◆
In Section 3.6.8, we saw that a common way to implement switch statements is to
create a set of code blocks and then index those blocks using a jump table. Consider
