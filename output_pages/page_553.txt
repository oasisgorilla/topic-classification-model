552
Chapter 5
Optimizing Program Performance
As shown previously, combine3 accumulates its result at the destination,
which in this case is the ﬁnal vector element. This value is therefore set ﬁrst to
1, then to 2 . 1 = 2, and then to 3 . 2 = 6. On the last iteration, this value is then
multiplied by itself to yield a ﬁnal value of 36. For the case of combine4, the vector
remains unchanged until the end, when the ﬁnal element is set to the computed
result 1 . 2 . 3 . 5 = 30.
Of course, our example showing the distinction between combine3 and
combine4 is highly contrived. One could argue that the behavior of combine4
more closely matches the intention of the function description. Unfortunately, a
compiler cannot make a judgment about the conditions under which a function
might be used and what the programmer’s intentions might be. Instead, when
given combine3 to compile, the conservative approach is to keep reading and
writing memory, even though this is less efﬁcient.
Practice Problem 5.4 (solution page 610)
When we use gcc to compile combine3 with command-line option -O2, we get
code with substantially better CPE performance than with -O1:
Integer
Floating point
Function
Page
Method
+
*
+
*
combine3
549
Compiled -O1
7.17
9.02
9.02
11.03
combine3
549
Compiled -O2
1.60
3.01
3.01
5.01
combine4
551
Accumulate in temporary
1.27
3.01
3.01
5.01
We achieve performance comparable to that for combine4, except for the case
of integer sum, but even it improves signiﬁcantly. On examining the assembly code
generated by the compiler, we ﬁnd an interesting variant for the inner loop:
Inner loop of combine3.
data_t = double, OP = *.
Compiled -O2
dest in %rbx, data+i in %rdx, data+length in %rax
Accumulated product in %xmm0
1
.L22:
loop:
2
vmulsd
(%rdx), %xmm0, %xmm0
Multiply product by data[i]
3
addq
$8, %rdx
Increment data+i
4
cmpq
%rax, %rdx
Compare to data+length
5
vmovsd
%xmm0, (%rbx)
Store product at dest
6
jne
.L22
If !=, goto loop
We can compare this to the version created with optimization level 1:
Inner loop of combine3.
data_t = double, OP = *.
Compiled -O1
dest in %rbx, data+i in %rdx, data+length in %rax
1
.L17:
loop:
2
vmovsd
(%rbx), %xmm0
Read product from dest
3
vmulsd
(%rdx), %xmm0, %xmm0
Multiply product by data[i]
4
vmovsd
%xmm0, (%rbx)
Store product at dest
