Section 3.8
Array Allocation and Access
297
(a) Original C code
/* Compute i,k of fixed matrix product */
int fix_prod_ele (fix_matrix A, fix_matrix B, long i, long k) {
long j;
int result = 0;
for (j = 0; j < N; j++)
result += A[i][j] * B[j][k];
return result;
}
(b) Optimized C code
1
/* Compute i,k of fixed matrix product */
2
int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) {
3
int *Aptr = &A[i][0];
/* Points to elements in row i of A
*/
4
int *Bptr = &B[0][k];
/* Points to elements in column k of B */
5
int *Bend = &B[N][k];
/* Marks stopping point for Bptr
*/
6
int result = 0;
7
do {
/* No need for initial test */
8
result += *Aptr * *Bptr;
/* Add next product to sum
*/
9
Aptr ++;
/* Move Aptr to next column */
10
Bptr += N;
/* Move Bptr to next row
*/
11
} while (Bptr != Bend);
/* Test for stopping point
*/
12
return result;
13
}
Figure 3.37
Original and optimized code to compute element i, k of matrix product
for ﬁxed-length arrays. The compiler performs these optimizations automatically.
The following is the actual assembly code generated by gcc for function fix_
prod_ele. We see that four registers are used as follows: %eax holds result, %rdi
holds Aptr, %rcx holds Bptr, and %rsi holds Bend.
int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k)
A in %rdi, B in %rsi, i in %rdx, k in %rcx
1
fix_prod_ele:
2
salq
$6, %rdx
Compute 64 * i
3
addq
%rdx, %rdi
Compute Aptr = xA + 64i = &A[i][0]
4
leaq
(%rsi,%rcx,4), %rcx
Compute Bptr = xB + 4k = &B[0][k]
5
leaq
1024(%rcx), %rsi
Compute Bend = xB + 4k + 1024 = &B[N][k]
6
movl
$0, %eax
Set result = 0
7
.L7:
loop:
8
movl
(%rdi), %edx
Read *Aptr
9
imull
(%rcx), %edx
Multiply by *Bptr
10
addl
%edx, %eax
Add to result
