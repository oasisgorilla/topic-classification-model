Section 3.10
Combining Control and Data in Machine-Level Programs
325
4
leaq
24(%rsp), %rsi
5
movq
%rsp, %rdi
6
call
iptoa
(b) With protector
int intlen(long x)
x in %rdi
1
intlen:
2
subq
$56, %rsp
3
movq
%fs:40, %rax
4
movq
%rax, 40(%rsp)
5
xorl
%eax, %eax
6
movq
%rdi, 8(%rsp)
7
leaq
8(%rsp), %rsi
8
leaq
16(%rsp), %rdi
9
call
iptoa
A. For both versions: What are the positions in the stack frame for buf, v, and
(when present) the canary value?
B. How does the rearranged ordering of the local variables in the protected
code provide greater security against a buffer overrun attack?
Limiting Executable Code Regions
A ﬁnal step is to eliminate the ability of an attacker to insert executable code into
a system. One method is to limit which memory regions hold executable code.
In typical programs, only the portion of memory holding the code generated by
the compiler need be executable. The other portions can be restricted to allow
just reading and writing. As we will see in Chapter 9, the virtual memory space
is logically divided into pages, typically with 2,048 or 4,096 bytes per page. The
hardware supports different forms of memory protection, indicating the forms of
access allowed by both user programs and the operating system kernel. Many sys-
tems allow control over three forms of access: read (reading data from memory),
write (storing data into memory), and execute (treating the memory contents as
machine-level code). Historically, the x86 architecture merged the read and exe-
cute access controls into a single 1-bit ﬂag, so that any page marked as readable
was also executable. The stack had to be kept both readable and writable, and
therefore the bytes on the stack were also executable. Various schemes were im-
plemented to be able to limit some pages to being readable but not executable,
but these generally introduced signiﬁcant inefﬁciencies.
More recently, AMD introduced an NX (for “no-execute”) bit into the mem-
ory protection for its 64-bit processors, separating the read and execute access
modes, and Intel followed suit. With this feature, the stack can be marked as be-
ing readable and writable, but not executable, and the checking of whether a page
is executable is performed in hardware, with no penalty in efﬁciency.
