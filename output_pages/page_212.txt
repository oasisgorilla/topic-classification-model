Section 3.2
Program Encodings
211
long mult2(long a, long b) {
long s = a * b;
return s;
}
Then we could generate an executable program prog as follows:
linux> gcc -Og -o prog main.c mstore.c
The ﬁle prog has grown to 8,655 bytes, since it contains not just the machine
code for the procedures we provided but also code used to start and terminate
the program as well as to interact with the operating system.
We can disassemble the ﬁle prog:
linux> objdump -d prog
The disassembler will extract various code sequences, including the following:
Disassembly of function sum in binary file prog
1
0000000000400540 <multstore>:
2
400540:
53
push
%rbx
3
400541:
48 89 d3
mov
%rdx,%rbx
4
400544:
e8 42 00 00 00
callq
40058b <mult2>
5
400549:
48 89 03
mov
%rax,(%rbx)
6
40054c:
5b
pop
%rbx
7
40054d:
c3
retq
8
40054e:
90
nop
9
40054f:
90
nop
This code is almost identical to that generated by the disassembly of mstore.c.
One important difference is that the addresses listed along the left are different—
the linker has shifted the location of this code to a different range of addresses. A
second difference is that the linker has ﬁlled in the address that the callq instruc-
tion should use in calling the function mult2 (line 4 of the disassembly). One task
for the linker is to match function calls with the locations of the executable code for
those functions. A ﬁnal difference is that we see two additional lines of code (lines
8–9). These instructions will have no effect on the program, since they occur after
the return instruction (line 7). They have been inserted to grow the code for the
function to 16 bytes, enabling a better placement of the next block of code in terms
of memory system performance.
3.2.3
Notes on Formatting
The assembly code generated by gcc is difﬁcult for a human to read. On one hand,
it contains information with which we need not be concerned, while on the other
hand, it does not provide any description of the program or how it works. For
example, suppose we give the command
linux> gcc -Og -S mstore.c
