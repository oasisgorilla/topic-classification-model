Section 4.5
Pipelined Y86-64 Implementations
481
exceptions correctly is a challenging aspect of any microprocessor design. They can
occur at unpredictable times, and they require creating a clean break in the ﬂow
of instructions through the processor pipeline. Our handling of the three internal
exceptions gives just a glimpse of the true complexity of correctly detecting and
handling exceptions.
Let us refer to the instruction causing the exception as the excepting instruc-
tion. In the case of an invalid instruction address, there is no actual excepting
instruction, but it is useful to think of there being a sort of “virtual instruction”
at the invalid address. In our simpliﬁed ISA model, we want the processor to halt
when it reaches an exception and to set the appropriate status code, as listed in Fig-
ure 4.5. It should appear that all instructions up to the excepting instruction have
completed, but none of the following instructions should have any effect on the
programmer-visible state. In a more complete design, the processor would con-
tinue by invoking an exception handler, a procedure that is part of the operating
system, but implementing this part of exception handling is beyond the scope of
our presentation.
In a pipelined system, exception handling involves several subtleties. First, it is
possible to have exceptions triggered by multiple instructions simultaneously. For
example, during one cycle of pipeline operation, we could have a halt instruction
in the fetch stage, and the data memory could report an out-of-bounds data
address for the instruction in the memory stage. We must determine which of these
exceptions the processor should report to the operating system. The basic rule is to
put priority on the exception triggered by the instruction that is furthest along the
pipeline. In the example above, this would be the out-of-bounds address attempted
by the instruction in the memory stage. In terms of the machine-language program,
the instruction in the memory stage should appear to execute before one in the
fetch stage, and therefore only this exception should be reported to the operating
system.
A second subtlety occurs when an instruction is ﬁrst fetched and begins
execution, causes an exception, and later is canceled due to a mispredicted branch.
The following is an example of such a program in its object-code form:
0x000: 6300
|
xorq %rax,%rax
0x002: 741600000000000000
|
jne
target
# Not taken
0x00b: 30f00100000000000000 |
irmovq $1, %rax
# Fall through
0x015: 00
|
halt
0x016:
| target:
0x016: ff
|
.byte 0xFF
# Invalid instruction code
In this program, the pipeline will predict that the branch should be taken,
and so it will fetch and attempt to use a byte with value 0xFF as an instruction
(generated in the assembly code using the .byte directive). The decode stage will
therefore detect an invalid instruction exception. Later, the pipeline will discover
that the branch should not be taken, and so the instruction at address 0x016
should never even have been fetched. The pipeline control logic will cancel this
instruction, but we want to avoid raising an exception.
