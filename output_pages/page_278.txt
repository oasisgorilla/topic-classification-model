Section 3.7
Procedures
277
space for local variables, and set up arguments for the procedures it calls. The
stack frames for most procedures are of ﬁxed size, allocated at the beginning of
the procedure. Some procedures, however, require variable-size frames. This issue
is discussed in Section 3.10.5. Procedure P can pass up to six integral values (i.e.,
pointers and integers) on the stack, but if Q requires more arguments, these can
be stored by P within its stack frame prior to the call.
In the interest of space and time efﬁciency, x86-64 procedures allocate only
the portions of stack frames they require. For example, many procedures have
six or fewer arguments, and so all of their parameters can be passed in registers.
Thus, parts of the stack frame diagrammed in Figure 3.25 may be omitted. Indeed,
many functions do not even require a stack frame. This occurs when all of the local
variables can be held in registers and the function does not call any other functions
(sometimes referred to as a leaf procedure, in reference to the tree structure of
procedure calls). For example, none of the functions we have examined thus far
required stack frames.
3.7.2
Control Transfer
Passing control from function P to function Q involves simply setting the program
counter (PC) to the starting address of the code for Q. However, when it later
comes time for Q to return, the processor must have some record of the code
location where it should resume the execution of P. This information is recorded
in x86-64 machines by invoking procedure Q with the instruction call Q. This
instruction pushes an address A onto the stack and sets the PC to the beginning
of Q. The pushed address A is referred to as the return address and is computed
as the address of the instruction immediately following the call instruction. The
counterpart instruction ret pops an address A off the stack and sets the PC to A.
The general forms of the call and ret instructions are described as follows:
Instruction
Description
call
Label
Procedure call
call
*Operand
Procedure call
ret
Return from call
(These instructions are referred to as callq and retq in the disassembly outputs
generated by the program objdump. The added sufﬁx ‘q’ simply emphasizes that
these are x86-64 versions of call and return instructions, not IA32. In x86-64
assembly code, both versions can be used interchangeably.)
The call instruction has a target indicating the address of the instruction
where the called procedure starts. Like jumps, a call can be either direct or indirect.
In assembly code, the target of a direct call is given as a label, while the target of
an indirect call is given by ‘*’ followed by an operand speciﬁer using one of the
formats described in Figure 3.3.
