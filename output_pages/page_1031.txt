1030
Chapter 12
Concurrent Programming
program counter, condition codes, and general-purpose register values. Each
thread shares the rest of the process context with the other threads. This includes
the entire user virtual address space, which consists of read-only text (code),
read/write data, the heap, and any shared library code and data areas. The threads
also share the same set of open ﬁles.
In an operational sense, it is impossible for one thread to read or write the
register values of another thread. On the other hand, any thread can access any
location in the shared virtual memory. If some thread modiﬁes a memory location,
then every other thread will eventually see the change if it reads that location.
Thus, registers are never shared, whereas virtual memory is always shared.
The memory model for the separate thread stacks is not as clean. These
stacks are contained in the stack area of the virtual address space and are usually
accessed independently by their respective threads. We say usually rather than
always, because different thread stacks are not protected from other threads. So
if a thread somehow manages to acquire a pointer to another thread’s stack, then
it can read and write any part of that stack. Our example program shows this in
line 26, where the peer threads reference the contents of the main thread’s stack
indirectly through the global ptr variable.
12.4.2
Mapping Variables to Memory
Variables in threaded C programs are mapped to virtual memory according to
their storage classes:
Global variables. A global variable is any variable declared outside of a func-
tion. At run time, the read/write area of virtual memory contains exactly
one instance of each global variable that can be referenced by any thread.
For example, the global ptr variable declared in line 5 has one run-time
instance in the read/write area of virtual memory. When there is only one
instance of a variable, we will denote the instance by simply using the
variable name—in this case, ptr.
Local automatic variables. A local automatic variable is one that is declared
inside a function without the static attribute. At run time, each thread’s
stack contains its own instances of any local automatic variables. This
is true even if multiple threads execute the same thread routine. For
example, there is one instance of the local variable tid, and it resides
on the stack of the main thread. We will denote this instance as tid.m.
As another example, there are two instances of the local variable myid,
one instance on the stack of peer thread 0 and the other on the stack of
peer thread 1. We will denote these instances as myid.p0 and myid.p1,
respectively.
Local static variables. A local static variable is one that is declared inside a func-
tion with the static attribute. As with global variables, the read/write
area of virtual memory contains exactly one instance of each local static
