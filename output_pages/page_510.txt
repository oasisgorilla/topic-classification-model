Homework Problems
509
. The GUI (graphic user interface) version displays the memory, program code,
and processor state in graphic windows. This provides a way to readily see how
the instructions ﬂow through the processors. The control panel also allows you
to reset, single-step, or run the simulator interactively.
. The text version runs the same simulator, but it only displays information by
printing to the terminal. This version is not as useful for debugging, but it
allows automated testing of the processor.
The control logic for the simulators is generated by translating the HCL
declarations of the logic blocks into C code. This code is then compiled and linked
with the rest of the simulation code. This combination makes it possible for you
to test out variants of the original designs using the simulators. Testing scripts are
also available that thoroughly exercise the different instructions and the different
hazard possibilities.
Bibliographic Notes
For those interested in learning more about logic design, the Katz and Borriello
logic design textbook [58] is a standard introductory text, emphasizing the use of
hardware description languages. Hennessy and Patterson’s computer architecture
textbook [46] provides extensive coverage of processor design, including both
simple pipelines, such as the one we have presented here, and advanced processors
that execute more instructions in parallel. Shriver and Smith [101] give a very
thorough presentation of an Intel-compatible x86-64 processor manufactured
by AMD.
Homework Problems
4.45 ◆
In Section 3.4.2, the x86-64 pushq instruction was described as decrementing the
stack pointer and then storing the register at the stack pointer location. So, if we
had an instruction of the form pushq REG, for some register REG, it would be
equivalent to the code sequence
subq $8,%rsp
Decrement stack pointer
movq REG, (%rsp)
Store REG on stack
A. In light of analysis done in Practice Problem 4.7, does this code sequence
correctly describe the behavior of the instruction pushq %rsp? Explain.
B. How could you rewrite the code sequence so that it correctly describes both
the cases where REG is %rsp as well as any other register?
4.46 ◆
In Section 3.4.2, the x86-64 popq instruction was described as copying the result
from the top of the stack to the destination register and then incrementing the
stack pointer. So, if we had an instruction of the form popq REG, it would be
equivalent to the code sequence
