Section 3.10
Combining Control and Data in Machine-Level Programs
317
Figure 3.40
Stack organization for
echo function. Character
array buf is just part of
the saved state. An out-of-
bounds write to buf can
corrupt the program state.
Stack frame
for caller
Stack frame
for echo
Return address
%rsp+24
[7]
buf = %rsp
[6][5][4][3][2][1][0]
while ((c = getchar()) != ’\n’ && c != EOF)
*dest++ = c;
if (c == EOF && dest == s)
/* No characters read */
return NULL;
*dest++ = ’\0’; /* Terminate string */
return s;
}
/* Read input line and write it back */
void echo()
{
char buf[8];
/* Way too small! */
gets(buf);
puts(buf);
}
The preceding code shows an implementation of the library function gets
to demonstrate a serious problem with this function. It reads a line from the
standard input, stopping when either a terminating newline character or some
error condition is encountered. It copies this string to the location designated by
argument s and terminates the string with a null character. We show the use of
gets in the function echo, which simply reads a line from standard input and echos
it back to standard output.
The problem with gets is that it has no way to determine whether sufﬁcient
space has been allocated to hold the entire string. In our echo example, we have
purposely made the buffer very small—just eight characters long. Any string
longer than seven characters will cause an out-of-bounds write.
By examining the assembly code generated by gcc for echo, we can infer how
the stack is organized:
void echo()
1
echo:
2
subq
$24, %rsp
Allocate 24 bytes on stack
3
movq
%rsp, %rdi
Compute buf as %rsp
4
call
gets
Call gets
5
movq
%rsp, %rdi
Compute buf as %rsp
