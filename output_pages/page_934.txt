Section 10.5
Robust Reading and Writing with the Rio Package
933
such as Web servers, then you must deal with short counts by repeatedly calling
read and write until all requested bytes have been transferred.
10.5
Robust Reading and Writing with the Rio Package
In this section, we will develop an I/O package, called the Rio (Robust I/O)
package, that handles these short counts for you automatically. The Rio package
provides convenient, robust, and efﬁcient I/O in applications such as network
programs that are subject to short counts. Rio provides two different kinds of
functions:
Unbuffered input and output functions. These functions transfer data directly
between memory and a ﬁle, with no application-level buffering. They are
especially useful for reading and writing binary data to and from networks.
Buffered input functions. These functions allow you to efﬁciently read text lines
and binary data from a ﬁle whose contents are cached in an application-
level buffer, similar to the one provided for standard I/O functions such as
printf. Unlike the buffered I/O routines presented in [110], the buffered
Rio input functions are thread-safe (Section 12.7.1) and can be inter-
leaved arbitrarily on the same descriptor. For example, you can read some
text lines from a descriptor, then some binary data, and then some more
text lines.
We are presenting the Rio routines for two reasons. First, we will be using
them in the network applications we develop in the next two chapters. Second, by
studying the code for these routines, you will gain a deeper understanding of Unix
I/O in general.
10.5.1
Rio Unbuffered Input and Output Functions
Applications can transfer data directly between memory and a ﬁle by calling the
rio_readn and rio_writen functions.
#include "csapp.h"
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
Returns: number of bytes transferred if OK, 0 on EOF (rio_readn only), −1 on error
The rio_readn function transfers up to n bytes from the current ﬁle position
of descriptor fd to memory location usrbuf. Similarly, the rio_writen function
transfers n bytes from location usrbuf to descriptor fd. The rio_readn function
can only return a short count if it encounters EOF. The rio_writen function never
returns a short count. Calls to rio_readn and rio_writen can be interleaved
arbitrarily on the same descriptor.
