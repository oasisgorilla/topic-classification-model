Section 10.12
Summary
949
These restrictions pose a problem for network applications because it is illegal
to use the lseek function on a socket. The ﬁrst restriction on stream I/O can be
worked around by adopting a discipline of ﬂushing the buffer before every input
operation. However, the only way to work around the second restriction is to
open two streams on the same open socket descriptor, one for reading and one
for writing:
FILE *fpin, *fpout;
fpin = fdopen(sockfd, "r");
fpout = fdopen(sockfd, "w");
But this approach has problems as well, because it requires the application to call
fclose on both streams in order to free the memory resources associated with
each stream and avoid a memory leak:
fclose(fpin);
fclose(fpout);
Each of these operations attempts to close the same underlying socket descriptor,
so the second close operation will fail. This is not a problem for sequential
programs, but closing an already closed descriptor in a threaded program is a
recipe for disaster (see Section 12.7.4).
Thus, we recommend that you not use the standard I/O functions for input
and output on network sockets. Use the robust Rio functions instead. If you need
formatted output, use the sprintf function to format a string in memory, and then
send it to the socket using rio_writen. If you need formatted input, use rio_
readlineb to read an entire text line, and then use sscanf to extract different
ﬁelds from the text line.
10.12
Summary
Linux provides a small number of system-level functions, based on the Unix I/O
model, that allow applications to open, close, read, and write ﬁles, to fetch ﬁle
metadata, and to perform I/O redirection. Linux read and write operations are
subject to short counts that applications must anticipate and handle correctly.
Instead of calling the Unix I/O functions directly, applications should use the Rio
package, which deals with short counts automatically by repeatedly performing
read and write operations until all of the requested data have been transferred.
The Linux kernel uses three related data structures to represent open ﬁles.
Entries in a descriptor table point to entries in the open ﬁle table, which point
to entries in the v-node table. Each process has its own distinct descriptor table,
while all processes share the same open ﬁle and v-node tables. Understanding the
general organization of these structures clariﬁes our understanding of both ﬁle
sharing and I/O redirection.
The standard I/O library is implemented on top of Unix I/O and provides a
powerful set of higher-level I/O routines. For most applications, standard I/O is the
