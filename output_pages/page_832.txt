Solutions to Practice Problems
831
shell handles it immediately and waits for the next command line. Otherwise,
the shell assumes that name is an executable ﬁle, which it loads and runs in the
context of an initial child process (job). The process group ID for the job is
identical to the PID of the child.
. Each job is identiﬁed by either a process ID (PID) or a job ID (JID), which
is a small arbitrary positive integer assigned by the shell. JIDs are denoted on
the command line by the preﬁx ‘%’. For example, ‘%5’ denotes JID 5, and ‘5’
denotes PID 5.
. If the command line ends with an ampersand, then the shell runs the job in
the background. Otherwise, the shell runs the job in the foreground.
. Typing Ctrl+C (Ctrl+Z) causes the kernel to send a SIGINT (SIGTSTP) signal
to your shell, which then forwards it to every process in the foreground process
group.2
. The jobs built-in command lists all background jobs.
. The bg job built-in command restarts job by sending it a SIGCONT signal
and then runs it in the background. The job argument can be either a PID or
a JID.
. The fg job built-in command restarts job by sending it a SIGCONT signal and
then runs it in the foreground.
. The shell reaps all of its zombie children. If any job terminates because it
receives a signal that was not caught, then the shell prints a message to the
terminal with the job’s PID and a description of the offending signal.
Figure 8.46 shows an example shell session.
Solutions to Practice Problems
Solution to Problem 8.1 (page 770)
Processes A and B are concurrent with respect to each other, as are B and C,
because their respective executions overlap—that is, one process starts before the
other ﬁnishes. Processes A and C are not concurrent because their executions do
not overlap; A ﬁnishes before C begins.
Solution to Problem 8.2 (page 779)
In our example program in Figure 8.15, the parent and child execute disjoint sets
of instructions. However, in this program, the parent and child execute nondisjoint
sets of instructions, which is possible because the parent and child have identical
code segments. This can be a difﬁcult conceptual hurdle, so be sure you understand
the solution to this problem. Figure 8.47 shows the process graph.
2. Note that this is a simpliﬁcation of the way that real shells work. With real shells, the kernel responds
to Ctrl+C (Ctrl+Z) by sending SIGINT (SIGTSTP) directly to each process in the terminal foreground
process group. The shell manages the membership of this group using the tcsetpgrp function, and
manages the attributes of the terminal using the tcsetattr function, both of which are outside the
scope of this book. See [62] for details.
