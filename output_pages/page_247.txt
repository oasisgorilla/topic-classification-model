246
Chapter 3
Machine-Level Representation of Programs
(a) Original C code
long lt_cnt = 0;
long ge_cnt = 0;
long absdiff_se(long x, long y)
{
long result;
if (x < y) {
lt_cnt++;
result = y - x;
}
else {
ge_cnt++;
result = x - y;
}
return result;
}
(b) Equivalent goto version
1
long gotodiff_se(long x, long y)
2
{
3
long result;
4
if (x >= y)
5
goto x_ge_y;
6
lt_cnt++;
7
result =
y - x;
8
return result;
9
x_ge_y:
10
ge_cnt++;
11
result = x - y;
12
return result;
13
}
(c) Generated assembly code
long absdiff_se(long x, long y)
x in %rdi, y in %rsi
1
absdiff_se:
2
cmpq
%rsi, %rdi
Compare x:y
3
jge
.L2
If >= goto x_ge_y
4
addq
$1, lt_cnt(%rip)
lt_cnt++
5
movq
%rsi, %rax
6
subq
%rdi, %rax
result = y - x
7
ret
Return
8
.L2:
x_ge_y:
9
addq
$1, ge_cnt(%rip)
ge_cnt++
10
movq
%rdi, %rax
11
subq
%rsi, %rax
result = x - y
12
ret
Return
Figure 3.16
Compilation of conditional statements. (a) C procedure absdiff_se
contains an if-else statement. The generated assembly code is shown (c), along with
(b) a C procedure gotodiff_se that mimics the control ﬂow of the assembly code.
assembly code. Using goto statements is generally considered a bad programming
style, since their use can make code very difﬁcult to read and debug. We use them
in our presentation as a way to construct C programs that describe the control
ﬂow of machine code. We call this style of programming “goto code.”
In the goto code (Figure 3.16(b)), the statement goto x_ge_y on line 5 causes
a jump to the label x_ge_y (since it occurs when x ≥y) on line 9. Continuing the
