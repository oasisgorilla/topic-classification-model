Chapter 3
Machine-Level Representation of Programs
201
machine code has shifted over the years from one of being able to write programs
directly in assembly code to one of being able to read and understand the code
generated by compilers.
In this chapter, we will learn the details of one particular assembly language
and see how C programs get compiled into this form of machine code. Reading
the assembly code generated by a compiler involves a different set of skills than
writing assembly code by hand. We must understand the transformations typical
compilers make in converting the constructs of C into machine code. Relative to
the computations expressed in the C code, optimizing compilers can rearrange
execution order, eliminate unneeded computations, replace slow operations with
faster ones, and even change recursive computations into iterative ones. Under-
standing the relation between source code and the generated assembly can often
be a challenge—it’s much like putting together a puzzle having a slightly differ-
ent design than the picture on the box. It is a form of reverse engineering—trying
to understand the process by which a system was created by studying the system
and working backward. In this case, the system is a machine-generated assembly-
language program, rather than something designed by a human. This simpliﬁes
the task of reverse engineering because the generated code follows fairly regu-
lar patterns and we can run experiments, having the compiler generate code for
many different programs. In our presentation, we give many examples and pro-
vide a number of exercises illustrating different aspects of assembly language and
compilers. This is a subject where mastering the details is a prerequisite to under-
standing the deeper and more fundamental concepts. Those who say “I understand
the general principles, I don’t want to bother learning the details” are deluding
themselves. It is critical for you to spend time studying the examples, working
through the exercises, and checking your solutions with those provided.
Our presentation is based on x86-64, the machine language for most of the
processors found in today’s laptop and desktop machines, as well as those that
power very large data centers and supercomputers. This language has evolved
over a long history, starting with Intel Corporation’s ﬁrst 16-bit processor in 1978,
through to the expansion to 32 bits, and most recently to 64 bits. Along the way,
features have been added to make better use of the available semiconductor tech-
nology, and to satisfy the demands of the marketplace. Much of the development
has been driven by Intel, but its rival Advanced Micro Devices (AMD) has also
made important contributions. The result is a rather peculiar design with features
that make sense only when viewed from a historical perspective. It is also laden
with features providing backward compatibility that are not used by modern com-
pilers and operating systems. We will focus on the subset of the features used by
gcc and Linux. This allows us to avoid much of the complexity and many of the
arcane features of x86-64.
Our technical presentation starts with a quick tour to show the relation be-
tween C, assembly code, and machine code. We then proceed to the details of
x86-64, starting with the representation and manipulation of data and the imple-
mentation of control. We see how control constructs in C, such as if, while, and
switch statements, are implemented. We then cover the implementation of pro-
cedures, including how the program maintains a run-time stack to support the
