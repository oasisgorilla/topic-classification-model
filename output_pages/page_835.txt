834
Chapter 8
Exceptional Control Flow
8
for (i=0; argv[i] != NULL; i++)
9
printf("
argv[%2d]: %s\n", i, argv[i]);
10
11
printf("\n");
12
printf("Environment variables:\n");
13
for (i=0; envp[i] != NULL; i++)
14
printf("
envp[%2d]: %s\n", i, envp[i]);
15
16
exit(0);
17
}
code/ecf/myecho.c
Solution to Problem 8.7 (page 800)
The sleep function returns prematurely whenever the sleeping process receives a
signal that is not ignored. But since the default action upon receipt of a SIGINT is
to terminate the process (Figure 8.26), we must install a SIGINT handler to allow
the sleep function to return. The handler simply catches the SIGNAL and returns
control to the sleep function, which returns immediately.
code/ecf/snooze.c
1
#include "csapp.h"
2
3
/* SIGINT handler */
4
void handler(int sig)
5
{
6
return; /* Catch the signal and return */
7
}
8
9
unsigned int snooze(unsigned int secs) {
10
unsigned int rc = sleep(secs);
11
12
printf("Slept for %d of %d secs.\n", secs-rc, secs);
13
return rc;
14
}
15
16
int main(int argc, char **argv) {
17
18
if (argc != 2) {
19
fprintf(stderr, "usage: %s <secs>\n", argv[0]);
20
exit(0);
21
}
22
23
if (signal(SIGINT, handler) == SIG_ERR) /* Install SIGINT */
24
unix_error("signal error\n");
/* handler
*/
25
(void)snooze(atoi(argv[1]));
