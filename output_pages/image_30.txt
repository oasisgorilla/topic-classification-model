16
CHAPTER  03    위장술
하기 어렵다. 이 중에서도 l은 얼핏 보기에 1과 구별하기 힘들기 때문에 변수명으
로 사용하기 가장 좋은 알파벳 중 하나다. 뿐만 아니라 대부분의 폰트에서 rn은 m
처럼 보이는 경우가 많다. 따라서 swimmer와 쉽게 구별하기 어려운 swirnrner
도 좋은 변수명이다. HashTable과 Hashtable처럼 한 글자의 대소문자만 살짝 변
경해서 변수명을 만드는 것도 좋은 방법이다. 
비슷하게 발음되고, 비슷하게 보이는 변수명 
xy_z라는 변수명 이외에 xy_Z, xy_ 
_z, _xy_z, _xyz, XY_Z, xY_z, Xy_z처럼 다
양한 변수명을 사용하지 말라는 법은 없다. 때로는 변수명을 소리나는 대로 혹은 
스펠링으로 기억하는 프로그래머를 많이 볼 수 있는데 대소문자나 밑줄로만 구별
되는 변수명이 이들을 혼란에 빠뜨릴 것이다. 
오버로드 그리고 당황 
C++에서 #define을 사용해 라이브러리 함수를 오버로드하자. 얼핏 보면 친숙한 
함수를 쓰고 있는 것처럼 보이겠지만 사실은 완전 다른 기능을 하게 할 수 있다. 
효율적인 오버로드 연산자 선택하기 
C++에서 +, -, *, / 등과 같은 연산자를 사칙 연산의 의미와 전혀 관련 없는 동작
을 하도록 오버로드하자. 스트로우스트 룹Stroustroup도 쉬프트 연산자를 I/O에 사
용했는데 우리도 그처럼 창의적이지 못할 이유가 없지 않은가? +를 오버로드할 때
에는 “i = i + 5;”가 “i += 5;”와 같은 의미를 갖지 않도록 해야 한다. 최첨단 연산자 
혼란 오버로딩 기법을 소개하겠다. 클래스의 ‘!’ 연산자를 오버로드하면서 뭔가를 
뒤집거나 부정하는 동작과는 아무 관련이 없는 동작을 하게 하는 것이 핵심이다. 
‘!’ 연산자가 정수를 반환하게 한다. ‘!’를 논리 연산자로 사용하려면 ‘! !’로 표기해
야 한다. 그러나 ‘!’ 연산 자체가 로직을 변경시키므로 결국 하나를 더 붙여서 ‘! ! !’
를 사용해야 한다. 여기서 말하는 ! 연산자는 불린 값 0이나 1을 반환하는 연산자
로 비트단위의 논리 부정 연산자 ~와 혼동하지 말자.
This eBook is licensed to 남궁진(jinvicky@naver.com). Personal use only
