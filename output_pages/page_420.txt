Section 4.2
Logic Design and the Hardware Control Language HCL
419
outputs valA and valB (short for “value A” and “value B”). The write port has
address input dstW (short for “destination W”) and data input valW (short for
“value W”).
The register ﬁle is not a combinational circuit, since it has internal storage. In
our implementation, however, data can be read from the register ﬁle as if it were
a block of combinational logic having addresses as inputs and the data as outputs.
When either srcA or srcB is set to some register ID, then, after some delay, the
value stored in the corresponding program register will appear on either valA or
valB. For example, setting srcA to 3 will cause the value of program register %rbx
to be read, and this value will appear on output valA.
The writing of words to the register ﬁle is controlled by the clock signal in
a manner similar to the loading of values into a clocked register. Every time the
clock rises, the value on input valW is written to the program register indicated by
the register ID on input dstW. When dstW is set to the special ID value 0xF, no
program register is written. Since the register ﬁle can be both read and written,
a natural question to ask is, “What happens if the circuit attempts to read and
write the same register simultaneously?” The answer is straightforward: if the
same register ID is used for both a read port and the write port, then, as the clock
rises, there will be a transition on the read port’s data output from the old value to
the new. When we incorporate the register ﬁle into our processor design, we will
make sure that we take this property into consideration.
Our processor has a random access memory for storing program data, as
illustrated below:
Data
memory
data out
data in
address
error
read
write
clock
This memory has a single address input, a data input for writing, and a data output
for reading. Like the register ﬁle, reading from our memory operates in a manner
similar to combinational logic: If we provide an address on the address input and
set the write control signal to 0, then after some delay, the value stored at that
address will appear on data out. The error signal will be set to 1 if the address
is out of range, and to 0 otherwise. Writing to the memory is controlled by the
clock: We set address to the desired address, data in to the desired value, and
write to 1. When we then operate the clock, the speciﬁed location in the memory
will be updated, as long as the address is valid. As with the read operation, the
error signal will be set to 1 if the address is invalid. This signal is generated by
combinational logic, since the required bounds checking is purely a function of
the address input and does not involve saving any state.
