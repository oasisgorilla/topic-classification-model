354
Chapter 3
Machine-Level Representation of Programs
1
long sum_col(long n, long A[NR(n)][NC(n)], long j) {
2
long i;
3
long result = 0;
4
for (i = 0; i < NR(n); i++)
5
result += A[i][j];
6
return result;
7
}
In compiling this program, gcc generates the following assembly code:
long sum_col(long n, long A[NR(n)][NC(n)], long j)
n in %rdi, A in %rsi, j in %rdx
1
sum_col:
2
leaq
1(,%rdi,4), %r8
3
leaq
(%rdi,%rdi,2), %rax
4
movq
%rax, %rdi
5
testq
%rax, %rax
6
jle
.L4
7
salq
$3, %r8
8
leaq
(%rsi,%rdx,8), %rcx
9
movl
$0, %eax
10
movl
$0, %edx
11
.L3:
12
addq
(%rcx), %rax
13
addq
$1, %rdx
14
addq
%r8, %rcx
15
cmpq
%rdi, %rdx
16
jne
.L3
17
rep; ret
18
.L4:
19
movl
$0, %eax
20
ret
Use your reverse engineering skills to determine the deﬁnitions of NR and NC.
3.67 ◆◆
For this exercise, we will examine the code generated by gcc for functions that have
structures as arguments and return values, and from this see how these language
features are typically implemented.
The following C code has a function process having structures as argument
and return values, and a function eval that calls process:
1
typedef struct {
2
long a[2];
3
long *p;
4
} strA;
5
