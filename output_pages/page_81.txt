80
Chapter 2
Representing and Manipulating Information
binary data are communicated over a network between different machines. A
common problem is for data produced by a little-endian machine to be sent to
a big-endian machine, or vice versa, leading to the bytes within the words being
in reverse order for the receiving program. To avoid such problems, code written
for networking applications must follow established conventions for byte order-
ing to make sure the sending machine converts its internal representation to the
network standard, while the receiving machine converts the network standard to
its internal representation. We will see examples of these conversions in Chap-
ter 11.
A second case where byte ordering becomes important is when looking at
the byte sequences representing integer data. This occurs often when inspecting
machine-level programs. As an example, the following line occurs in a ﬁle that
gives a text representation of the machine-level code for an Intel x86-64 processor:
4004d3:
01 05 43 0b 20 00
add
%eax,0x200b43(%rip)
This line was generated by a disassembler, a tool that determines the instruction
sequence represented by an executable program ﬁle. We will learn more about
disassemblers and how to interpret lines such as this in Chapter 3. For now, we
simply note that this line states that the hexadecimal byte sequence 01 05 43 0b
20 00 is the byte-level representation of an instruction that adds a word of data
to the value stored at an address computed by adding 0x200b43 to the current
value of the program counter, the address of the next instruction to be executed.
If we take the ﬁnal 4 bytes of the sequence 43 0b 20 00 and write them in reverse
order, we have 00 20 0b 43. Dropping the leading 0, we have the value 0x200b43,
the numeric value written on the right. Having bytes appear in reverse order
is a common occurrence when reading machine-level program representations
generated for little-endian machines such as this one. The natural way to write a
byte sequence is to have the lowest-numbered byte on the left and the highest on
the right, but this is contrary to the normal way of writing numbers with the most
signiﬁcant digit on the left and the least on the right.
A third case where byte ordering becomes visible is when programs are
written that circumvent the normal type system. In the C language, this can be
done using a cast or a union to allow an object to be referenced according to
a different data type from which it was created. Such coding tricks are strongly
discouraged for most application programming, but they can be quite useful and
even necessary for system-level programming.
Figure 2.4 shows C code that uses casting to access and print the byte rep-
resentations of different program objects. We use typedef to deﬁne data type
byte_pointer as a pointer to an object of type unsigned char. Such a byte pointer
references a sequence of bytes where each byte is considered to be a nonnega-
tive integer. The ﬁrst routine show_bytes is given the address of a sequence of
bytes, indicated by a byte pointer, and a byte count. The byte count is speciﬁed as
having data type size_t, the preferred data type for expressing the sizes of data
structures. It prints the individual bytes in hexadecimal. The C formatting direc-
tive %.2x indicates that an integer should be printed in hexadecimal with at least
2 digits.
