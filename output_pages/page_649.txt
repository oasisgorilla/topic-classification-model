648
Chapter 6
The Memory Hierarchy
Figure 6.22, the cache at level k has room for four blocks and currently contains
copies of blocks 4, 9, 14, and 3.
Data are always copied back and forth between level k and level k + 1 in
block-size transfer units. It is important to realize that while the block size is ﬁxed
between any particular pair of adjacent levels in the hierarchy, other pairs of levels
can have different block sizes. For example, in Figure 6.21, transfers between L1
and L0 typically use word-size blocks. Transfers between L2 and L1 (and L3 and
L2, and L4 and L3) typically use blocks of tens of bytes. And transfers between L5
and L4 use blocks with hundreds or thousands of bytes. In general, devices lower
in the hierarchy (further from the CPU) have longer access times, and thus tend
to use larger block sizes in order to amortize these longer access times.
Cache Hits
When a program needs a particular data object d from level k + 1, it ﬁrst looks
for d in one of the blocks currently stored at level k. If d happens to be cached
at level k, then we have what is called a cache hit. The program reads d directly
from level k, which by the nature of the memory hierarchy is faster than reading
d from level k + 1. For example, a program with good temporal locality might read
a data object from block 14, resulting in a cache hit from level k.
Cache Misses
If, on the other hand, the data object d is not cached at level k, then we have what
is called a cache miss. When there is a miss, the cache at level k fetches the block
containing d from the cache at level k + 1, possibly overwriting an existing block
if the level k cache is already full.
This process of overwriting an existing block is known as replacing or evicting
the block. The block that is evicted is sometimes referred to as a victim block.
The decision about which block to replace is governed by the cache’s replacement
policy. For example, a cache with a random replacement policy would choose a
random victim block. A cache with a least recently used (LRU)replacement policy
would choose the block that was last accessed the furthest in the past.
After the cache at level k has fetched the block from level k + 1, the program
can read d from level k as before. For example, in Figure 6.22, reading a data object
from block 12 in the level k cache would result in a cache miss because block 12 is
not currently stored in the level k cache. Once it has been copied from level k + 1
to level k, block 12 will remain there in expectation of later accesses.
Kinds of Cache Misses
It is sometimes helpful to distinguish between different kinds of cache misses. If
the cache at level k is empty, then any access of any data object will miss. An
empty cache is sometimes referred to as a cold cache, and misses of this kind are
called compulsory misses or cold misses. Cold misses are important because they
are often transient events that might not occur in steady state, after the cache has
been warmed up by repeated memory accesses.
