288
Chapter 3
Machine-Level Representation of Programs
(a) Calling function
long P(long x, long y)
{
long u = Q(y);
long v = Q(x);
return u + v;
}
(b) Generated assembly code for the calling function
long P(long x, long y)
x in %rdi, y in %rsi
1
P:
2
pushq
%rbp
Save %rbp
3
pushq
%rbx
Save %rbx
4
subq
$8, %rsp
Align stack frame
5
movq
%rdi, %rbp
Save x
6
movq
%rsi, %rdi
Move y to first argument
7
call
Q
Call Q(y)
8
movq
%rax, %rbx
Save result
9
movq
%rbp, %rdi
Move x to first argument
10
call
Q
Call Q(x)
11
addq
%rbx, %rax
Add saved Q(y) to Q(x)
12
addq
$8, %rsp
Deallocate last part of stack
13
popq
%rbx
Restore %rbx
14
popq
%rbp
Restore %rbp
15
ret
Figure 3.34
Code demonstrating use of callee-saved registers. Value x must be
preserved during the ﬁrst call, and value Q(y) must be preserved during the second.
we can see that the code generated by gcc uses two callee-saved registers: %rbp
to hold x, and %rbx to hold the computed value of Q(y). At the beginning of the
function, it saves the values of these two registers on the stack (lines 2–3). It copies
argument x to %rbp before the ﬁrst call to Q (line 5). It copies the result of this call
to %rbx before the second call to Q (line 8). At the end of the function (lines 13–
14), it restores the values of the two callee-saved registers by popping them off the
stack. Note how they are popped in the reverse order from how they were pushed,
to account for the last-in, ﬁrst-out discipline of a stack.
Practice Problem 3.34 (solution page 376)
Consider a function P, which generates local values, named a0–a8. It then calls
function Q using these generated values as arguments. Gcc produces the following
code for the ﬁrst part of P:
