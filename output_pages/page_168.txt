Homework Problems
167
2.65 ◆◆◆◆
Write code to implement the following function:
/* Return 1 when x contains an odd number of 1s; 0 otherwise.
Assume w=32 */
int odd_ones(unsigned x);
Your function should follow the bit-level integer coding rules (page 164),
except that you may assume that data type int has w = 32 bits.
Your code should contain a total of at most 12 arithmetic, bitwise, and logical
operations.
2.66 ◆◆◆
Write code to implement the following function:
/*
* Generate mask indicating leftmost 1 in x.
Assume w=32.
* For example, 0xFF00 -> 0x8000, and 0x6600 --> 0x4000.
* If x = 0, then return 0.
*/
int leftmost_one(unsigned x);
Your function should follow the bit-level integer coding rules (page 164),
except that you may assume that data type int has w = 32 bits.
Your code should contain a total of at most 15 arithmetic, bitwise, and logical
operations.
Hint: First transform x into a bit vector of the form [0 . . . 011 . . . 1].
2.67 ◆◆
You are given the task of writing a procedure int_size_is_32() that yields 1
when run on a machine for which an int is 32 bits, and yields 0 otherwise. You are
not allowed to use the sizeof operator. Here is a ﬁrst attempt:
1
/* The following code does not run properly on some machines */
2
int bad_int_size_is_32() {
3
/* Set most significant bit (msb) of 32-bit machine */
4
int set_msb = 1 << 31;
5
/* Shift past msb of 32-bit word */
6
int beyond_msb = 1 << 32;
7
8
/* set_msb is nonzero when word size >= 32
9
beyond_msb is zero when word size <= 32
*/
10
return set_msb && !beyond_msb;
11
}
When compiled and run on a 32-bit SUN SPARC, however, this procedure
returns 0. The following compiler message gives us an indication of the problem:
warning: left shift count >= width of type
