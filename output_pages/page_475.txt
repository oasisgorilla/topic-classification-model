474
Chapter 4
Processor Architecture
F
0x000: irmovq $10,%rdx
# prog4
# prog4
0x00a: irmovq  $3,%rax
0x014: addq %rdx,%rax
0x016: halt
D
E
M
W
F
D
E
M
W
F
D
E
M
W
F
D
E
M
W
1
2
3
4
5
6
7
8
srcA = %rdx
srcB = %rax
M_dstE = %rdx
M_valE = 10
valA      M_valE = 10
valB      e_valE = 3
Cycle 4
D
M
E_dstE = %rax
e_valE      0 + 3 = 3
E
Figure 4.51
Pipelined execution of prog4 using forwarding. In cycle 4, the decode-
stage logic detects a pending write to register %rdx in the memory stage. It also detects
that a new value is being computed for register %rax in the execute stage. It uses these
as the values for valA and valB rather than the values read from the register ﬁle.
To exploit data forwarding to its full extent, we can also pass newly computed
values from the execute stage to the decode stage, avoiding the need to stall for
program prog4, as illustrated in Figure 4.51. In cycle 4, the decode-stage logic
detects a pending write to register %rdx in the memory stage, and also that the
value being computed by the ALU in the execute stage will later be written to
register %rax. It can use the value in the memory stage (signal M_valE) for operand
valA. It can also use the ALU output (signal e_valE) for operand valB. Note that
using the ALU output does not introduce any timing problems. The decode stage
only needs to generate signals valA and valB by the end of the clock cycle so that
pipeline register E can be loaded with the results from the decode stage as the
clock rises to start the next cycle. The ALU output will be valid before this point.
The uses of forwarding illustrated in programs prog2 to prog4 all involve
the forwarding of values generated by the ALU and destined for write port E.
Forwarding can also be used with values read from the memory and destined for
write port M. From the memory stage, we can forward the value that has just been
read from the data memory (signal m_valM). From the write-back stage, we can
forward the pending write to port M (signal W_valM). This gives a total of ﬁve
different forwarding sources (e_valE, m_valM, M_valE, W_valM, and W_valE) and
two different forwarding destinations (valA and valB).
