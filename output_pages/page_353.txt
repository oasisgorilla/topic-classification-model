352
Chapter 3
Machine-Level Representation of Programs
long switch_prob(long x, long n)
x in %rdi, n in %rsi
1
0000000000400590 <switch_prob>:
2
400590:
48 83 ee 3c
sub
$0x3c,%rsi
3
400594:
48 83 fe 05
cmp
$0x5,%rsi
4
400598:
77 29
ja
4005c3 <switch_prob+0x33>
5
40059a:
ff 24 f5 f8 06 40 00
jmpq
*0x4006f8(,%rsi,8)
6
4005a1:
48 8d 04 fd 00 00 00
lea
0x0(,%rdi,8),%rax
7
4005a8:
00
8
4005a9:
c3
retq
9
4005aa:
48 89 f8
mov
%rdi,%rax
10
4005ad:
48 c1 f8 03
sar
$0x3,%rax
11
4005b1:
c3
retq
12
4005b2:
48 89 f8
mov
%rdi,%rax
13
4005b5:
48 c1 e0 04
shl
$0x4,%rax
14
4005b9:
48 29 f8
sub
%rdi,%rax
15
4005bc:
48 89 c7
mov
%rax,%rdi
16
4005bf:
48 0f af ff
imul
%rdi,%rdi
17
4005c3:
48 8d 47 4b
lea
0x4b(%rdi),%rax
18
4005c7:
c3
retq
Figure 3.53
Disassembled code for Problem 3.63.
3.64 ◆◆◆
Consider the following source code, where R, S, and T are constants declared with
#define:
1
long A[R][S][T];
2
3
long store_ele(long i, long j, long k, long *dest)
4
{
5
*dest = A[i][j][k];
6
return sizeof(A);
7
}
In compiling this program, gcc generates the following assembly code:
long store_ele(long i, long j, long k, long *dest)
i in %rdi, j in %rsi, k in %rdx, dest in %rcx
1
store_ele:
2
leaq
(%rsi,%rsi,2), %rax
3
leaq
(%rsi,%rax,4), %rax
4
movq
%rdi, %rsi
5
salq
$6, %rsi
6
addq
%rsi, %rdi
7
addq
%rax, %rdi
