Section 3.10
Combining Control and Data in Machine-Level Programs
327
(a) C code
long vframe(long n, long idx, long *q)
{
long i;
long *p[n];
p[0] = &i;
for (i = 1; i < n; i++)
p[i] = q;
return *p[idx];
}
(b) Portions of generated assembly code
long vframe(long n, long idx, long *q)
n in %rdi, idx in %rsi, q in %rdx
Only portions of code shown
1
vframe:
2
pushq
%rbp
Save old %rbp
3
movq
%rsp, %rbp
Set frame pointer
4
subq
$16, %rsp
Allocate space for i (%rsp = s1)
5
leaq
22(,%rdi,8), %rax
6
andq
$-16, %rax
7
subq
%rax, %rsp
Allocate space for array p (%rsp = s2)
8
leaq
7(%rsp), %rax
9
shrq
$3, %rax
10
leaq
0(,%rax,8), %r8
Set %r8 to &p[0]
11
movq
%r8, %rcx
Set %rcx to &p[0] (%rcx = p)
. . .
Code for initialization loop
i in %rax and on stack, n in %rdi, p in %rcx, q in %rdx
12
.L3:
loop:
13
movq
%rdx, (%rcx,%rax,8)
Set p[i] to q
14
addq
$1, %rax
Increment i
15
movq
%rax, -8(%rbp)
Store on stack
16
.L2:
17
movq
-8(%rbp), %rax
Retrieve i from stack
18
cmpq
%rdi, %rax
Compare i:n
19
jl
.L3
If <, goto loop
. . .
Code for function exit
20
leave
Restore %rbp and %rsp
21
ret
Return
Figure 3.43
Function requiring the use of a frame pointer. The variable-size array implies that the size of
the stack frame cannot be determined at compile time.
