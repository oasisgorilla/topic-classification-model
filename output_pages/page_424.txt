Section 4.3
Sequential Y86-64 Implementations
423
Stage
OPq rA, rB
rrmovq rA, rB
irmovq V, rB
Fetch
icode:ifun ←M1[PC]
icode:ifun ←M1[PC]
icode:ifun ←M1[PC]
rA :rB ←M1[PC + 1]
rA :rB ←M1[PC + 1]
rA :rB ←M1[PC + 1]
valC ←M8[PC + 2]
valP ←PC + 2
valP ←PC + 2
valP ←PC + 10
Decode
valA ←R[rA]
valA ←R[rA]
valB ←R[rB]
Execute
valE ←valB OP valA
valE ←0 + valA
valE ←0 + valC
Set CC
Memory
Write back
R[rB] ←valE
R[rB] ←valE
R[rB] ←valE
PC update
PC ←valP
PC ←valP
PC ←valP
Figure 4.18
Computations in sequential implementation of Y86-64 instructions OPq, rrmovq, and
irmovq. These instructions compute a value and store the result in a register. The notation icode:ifun
indicates the two components of the instruction byte, while rA:rB indicates the two components of the
register speciﬁer byte. The notation M1[x] indicates accessing (either reading or writing) 1 byte at memory
location x, while M8[x] indicates accessing 8 bytes.
then written to the register ﬁle. Similar processing occurs for irmovq, except that
we use constant value valC for the ﬁrst ALU input. In addition, we must increment
the program counter by 10 for irmovq due to the long instruction format. Neither
of these instructions changes the condition codes.
Practice Problem 4.13 (solution page 521)
Fill in the right-hand column of the following table to describe the processing of
the irmovq instruction on line 4 of the object code in Figure 4.17:
Generic
Speciﬁc
Stage
irmovq V, rB
irmovq $128, %rsp
Fetch
icode:ifun ←M1[PC]
rA :rB ←M1[PC + 1]
valC ←M8[PC + 2]
valP ←PC + 10
Decode
Execute
valE ←0 + valC
