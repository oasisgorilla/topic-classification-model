Section 3.6
Control
257
(a) C code
long fact_do(long n)
{
long result = 1;
do {
result *= n;
n = n-1;
} while (n > 1);
return result;
}
(b) Equivalent goto version
long fact_do_goto(long n)
{
long result = 1;
loop:
result *= n;
n = n-1;
if (n > 1)
goto loop;
return result;
}
(c) Corresponding assembly-language code
long fact_do(long n)
n in %rdi
1
fact_do:
2
movl
$1, %eax
Set result = 1
3
.L2:
loop:
4
imulq
%rdi, %rax
Compute result *= n
5
subq
$1, %rdi
Decrement n
6
cmpq
$1, %rdi
Compare n:1
7
jg
.L2
If >, goto loop
8
rep; ret
Return
Figure 3.19
Code for do–while version of factorial program. A conditional jump
causes the program to loop.
As an example, Figure 3.19(a) shows an implementation of a routine to com-
pute the factorial of its argument, written n!, with a do-while loop. This function
only computes the proper value for n > 0.
Practice Problem 3.22 (solution page 369)
A. Try to calculate 14! with a 32-bit int. Verify whether the computation of 14!
overﬂows.
B. What if the computation is done with a 64-bit long int?
The goto code shown in Figure 3.19(b) shows how the loop gets turned into
a lower-level combination of tests and conditional jumps. Following the initial-
ization of result, the program begins looping. First it executes the body of the
loop, consisting here of updates to variables result and n. It then tests whether
n > 1, and, if so, it jumps back to the beginning of the loop. Figure 3.19(c) shows
