312
Chapter 3
Machine-Level Representation of Programs
Aside
A case of mandatory alignment
For most x86-64 instructions, keeping data aligned improves efﬁciency, but it does not affect program
behavior. On the other hand, some models of Intel and AMD processors will not work correctly
with unaligned data for some of the SSE instructions implementing multimedia operations. These
instructions operate on 16-byte blocks of data, and the instructions that transfer data between the SSE
unit and memory require the memory addresses to be multiples of 16. Any attempt to access memory
with an address that does not satisfy this alignment will lead to an exception (see Section 8.1), with the
default behavior for the program to terminate.
As a result, any compiler and run-time system for an x86-64 processor must ensure that any memory
allocated to hold a data structure that may be read from or stored into an SSE register must satisfy a
16-byte alignment. This requirement has the following two consequences:
. The starting address for any block generated by a memory allocation function (alloca, malloc,
calloc, or realloc) must be a multiple of 16.
. The stack frame for most functions must be aligned on a 16-byte boundary. (This requirement has
a number of exceptions.)
More recent versions of x86-64 processors implement the AVX multimedia instructions. In addi-
tion to providing a superset of the SSE instructions, processors supporting AVX also do not have a
mandatory alignment requirement.
int
g;
char
*h;
} rec;
A. What are the byte offsets of all the ﬁelds in the structure?
B. What is the total size of the structure?
C. Rearrange the ﬁelds of the structure to minimize wasted space, and then
show the byte offsets and total size for the rearranged structure.
3.10
Combining Control and Data in
Machine-Level Programs
So far, we have looked separately at how machine-level code implements the
control aspects of a program and how it implements different data structures. In
this section, we look at ways in which data and control interact with each other.
We start by taking a deep look into pointers, one of the most important concepts
in the C programming language, but one for which many programmers only have
a shallow understanding. We review the use of the symbolic debugger gdb for
examining the detailed operation of machine-level programs. Next, we see how
understanding machine-level programs enables us to study buffer overﬂow, an
important security vulnerability in many real-world systems. Finally, we examine
