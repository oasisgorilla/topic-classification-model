728
Chapter 7
Linking
code/link/main-relo.d
1
0000000000000000 <main>:
2
0:
48 83 ec 08
sub
$0x8,%rsp
3
4:
be 02 00 00 00
mov
$0x2,%esi
4
9:
bf 00 00 00 00
mov
$0x0,%edi
%edi = &array
5
a: R_X86_64_32 array
Relocation entry
6
e:
e8 00 00 00 00
callq
13 <main+0x13>
sum()
7
f: R_X86_64_PC32 sum-0x4
Relocation entry
8
13:
48 83 c4 08
add
$0x8,%rsp
9
17:
c3
retq
code/link/main-relo.d
Figure 7.11
Code and relocation entries from main.o. The original C code is in Figure 7.1.
Let’s see how the linker uses this algorithm to relocate the references in our
example program in Figure 7.1. Figure 7.11 shows the disassembled code from
main.o, as generated by the GNU objdump tool (objdump -dx main.o).
The main function references two global symbols, array and sum. For each
reference, the assembler has generated a relocation entry, which is displayed on
the following line.2 The relocation entries tell the linker that the reference to sum
should be relocated using a 32-bit PC-relative address, and the reference to array
should be relocated using a 32-bit absolute address. The next two sections detail
how the linker relocates these references.
Relocating PC-Relative References
In line 6 in Figure 7.11, function main calls the sum function, which is deﬁned in
module sum.o. The call instruction begins at section offset 0xe and consists of the
1-byte opcode 0xe8, followed by a placeholder for the 32-bit PC-relative reference
to the target sum.
The corresponding relocation entry r consists of four ﬁelds:
r.offset = 0xf
r.symbol = sum
r.type
= R_X86_64_PC32
r.addend = -4
These ﬁelds tell the linker to modify the 32-bit PC-relative reference starting at
offset 0xf so that it will point to the sum routine at run time. Now, suppose that
the linker has determined that
ADDR(s) = ADDR(.text) = 0x4004d0
2. Recall that relocation entries and instructions are actually stored in different sections of the object
ﬁle. The objdump tool displays them together for convenience.
