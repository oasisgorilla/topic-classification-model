Section 3.6
Control
243
and the conditions under which they jump match those of the set instructions
(see Figure 3.14). As with the set instructions, some of the underlying machine
instructions have multiple names. Conditional jumps can only be direct.
3.6.4
Jump Instruction Encodings
For the most part, we will not concern ourselves with the detailed format of ma-
chine code. On the other hand, understanding how the targets of jump instructions
are encoded will become important when we study linking in Chapter 7. In ad-
dition, it helps when interpreting the output of a disassembler. In assembly code,
jump targets are written using symbolic labels. The assembler, and later the linker,
generate the proper encodings of the jump targets. There are several different en-
codings for jumps, but some of the most commonly used ones are PC relative. That
is, they encode the difference between the address of the target instruction and
the address of the instruction immediately following the jump. These offsets can
be encoded using 1, 2, or 4 bytes. A second encoding method is to give an “abso-
lute” address, using 4 bytes to directly specify the target. The assembler and linker
select the appropriate encodings of the jump destinations.
As an example of PC-relative addressing, the following assembly code for a
function was generated by compiling a ﬁle branch.c. It contains two jumps: the
jmp instruction on line 2 jumps forward to a higher address, while the jg instruction
on line 7 jumps back to a lower one.
1
movq
%rdi, %rax
2
jmp
.L2
3
.L3:
4
sarq
%rax
5
.L2:
6
testq
%rax, %rax
7
jg
.L3
8
rep; ret
The disassembled version of the .o format generated by the assembler is as
follows:
1
0:
48 89 f8
mov
%rdi,%rax
2
3:
eb 03
jmp
8 <loop+0x8>
3
5:
48 d1 f8
sar
%rax
4
8:
48 85 c0
test
%rax,%rax
5
b:
7f f8
jg
5 <loop+0x5>
6
d:
f3 c3
repz retq
In the annotations on the right generated by the disassembler, the jump targets
are indicated as 0x8 for the jump instruction on line 2 and 0x5 for the jump
instruction on line 5 (the disassembler lists all numbers in hexadecimal). Looking
at the byte encodings of the instructions, however, we see that the target of the ﬁrst
jump instruction is encoded (in the second byte) as 0x03. Adding this to 0x5, the
