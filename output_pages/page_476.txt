Section 4.5
Pipelined Y86-64 Implementations
475
The expanded diagrams of Figures 4.49 to 4.51 also show how the decode-
stage logic can determine whether to use a value from the register ﬁle or to use
a forwarded value. Associated with every value that will be written back to the
register ﬁle is the destination register ID. The logic can compare these IDs with
the source register IDs srcA and srcB to detect a case for forwarding. It is possible
to have multiple destination register IDs match one of the source IDs. We must
establish a priority among the different forwarding sources to handle such cases.
This will be discussed when we look at the detailed design of the forwarding logic.
Figure 4.52 shows the structure of PIPE, an extension of PIPE−that can
handle data hazards by forwarding. Comparing this to the structure of PIPE−
(Figure 4.41), we can see that the values from the ﬁve forwarding sources are fed
back to the two blocks labeled “Sel+Fwd A” and “Fwd B” in the decode stage.
The block labeled “Sel+Fwd A” combines the role of the block labeled “Select A”
in PIPE−with the forwarding logic. It allows valA for pipeline register E to be
either the incremented program counter valP, the value read from the A port
of the register ﬁle, or one of the forwarded values. The block labeled “Fwd B”
implements the forwarding logic for source operand valB.
Load/Use Data Hazards
One class of data hazards cannot be handled purely by forwarding, because mem-
ory reads occur late in the pipeline. Figure 4.53 illustrates an example of a load/use
hazard, where one instruction (the mrmovq at address 0x028) reads a value from
memory for register %rax while the next instruction (the addq at address 0x032)
needs this value as a source operand. Expanded views of cycles 7 and 8 are shown
in the lower part of the ﬁgure, where we assume all program registers initially have
value 0. The addq instruction requires the value of the register in cycle 7, but it is
not generated by the mrmovq instruction until cycle 8. In order to “forward” from
the mrmovq to the addq, the forwarding logic would have to make the value go
backward in time! Since this is clearly impossible, we must ﬁnd some other mech-
anism for handling this form of data hazard. (The data hazard for register %rbx,
with the value being generated by the irmovq instruction at address 0x01e and
used by the addq instruction at address 0x032, can be handled by forwarding.)
As Figure 4.54 demonstrates, we can avoid a load/use data hazard with a
combination of stalling and forwarding. This requires modiﬁcations of the con-
trol logic, but it can use existing bypass paths. As the mrmovq instruction passes
through the execute stage, the pipeline control logic detects that the instruction
in the decode stage (the addq) requires the result read from memory. It stalls the
instruction in the decode stage for one cycle, causing a bubble to be injected into
the execute stage. As the expanded view of cycle 8 shows, the value read from
memory can then be forwarded from the memory stage to the addq instruction
in the decode stage. The value for register %rbx is also forwarded from the write-
back to the memory stage. As indicated in the pipeline diagram by the arrow from
the box labeled “D” in cycle 7 to the box labeled “E” in cycle 8, the injected bub-
ble replaces the addq instruction that would normally continue ﬂowing through
the pipeline.
