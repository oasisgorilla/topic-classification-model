1086
References
Transactions on Electronic Computers EC-
11:223–235, April 1962.
[64]
D. Knuth. The Art of Computer Programming,
Volume 1: Fundamental Algorithms, Third
Edition. Addison-Wesley, 1997.
[65]
J. Kurose and K. Ross. Computer Networking: A
Top-Down Approach, Sixth Edition. Addison-
Wesley, 2012.
[66]
M. Lam, E. Rothberg, and M. Wolf. The
cache performance and optimizations of
blocked algorithms. In Proceedings of the
4th International Conference on Architectural
Support for Programming Languages and
Operating Systems (ASPLOS), pages 63–74.
ACM, April 1991.
[67]
D. Lea. A memory allocator. Available at
http://gee.cs.oswego.edu/dl/html/malloc.html,
1996.
[68]
C. E. Leiserson and J. B. Saxe. Retiming
synchronous circuitry. Algorithmica 6(1–6),
June 1991.
[69]
J. R. Levine. Linkers and Loaders. Morgan
Kaufmann, 1999.
[70]
David Levinthal. Performance Analysis Guide
for Intel Core i7 Processor and Intel Xeon
5500 Processors. Available at https://software
.intel.com/sites/products/collateral/hpc/vtune/
performance_analysis_guide.pdf.
[71]
C. Lin and L. Snyder. Principles of Parallel
Programming. Addison Wesley, 2008.
[72]
Y. Lin and D. Padua. Compiler analysis of
irregular memory accesses. In Proceedings of
the 2000 ACM Conference on Programming
Language Design and Implementation (PLDI),
pages 157–168. ACM, June 2000.
[73]
J. L. Lions. Ariane 5 Flight 501 failure. Technical
Report, European Space Agency, July 1996.
[74]
S. Macguire. Writing Solid Code. Microsoft
Press, 1993.
[75]
S. A. Mahlke, W. Y. Chen, J. C. Gyllenhal, and
W. W. Hwu. Compiler code transformations for
superscalar-based high-performance systems.
In Proceedings of the 1992 ACM/IEEE
Conference on Supercomputing, pages 808–817.
ACM, 1992.
[76]
E. Marshall. Fatal error: How Patriot over-
looked a Scud. Science, page 1347, March 13,
1992.
[77]
M. Matz, J. Hubiˇ
cka, A. Jaeger, and M. Mitchell.
System V application binary interface AMD64
architecture processor supplement. Technical
Report, x86-64.org, 2013. Available at http://
www.x86-64.org/documentation_folder/abi-0
.99.pdf.
[78]
J. Morris, M. Satyanarayanan, M. Conner,
J. Howard, D. Rosenthal, and F. Smith. Andrew:
A distributed personal computing environment.
Communications of the ACM, pages 184–201,
March 1986.
[79]
T. Mowry, M. Lam, and A. Gupta. Design
and evaluation of a compiler algorithm
for prefetching. In Proceedings of the 5th
International Conference on Architectural
Support for Programming Languages and
Operating Systems (ASPLOS), pages 62–73.
ACM, October 1992.
[80]
S. S. Muchnick. Advanced Compiler Design and
Implementation. Morgan Kaufmann, 1997.
[81]
S. Nath and P
. Gibbons. Online maintenance of
very large random samples on ﬂash storage. In
Proceedings of VLDB, pages 970–983. VLDB
Endowment, August 2008.
[82]
M. Overton. Numerical Computing with IEEE
Floating Point Arithmetic. SIAM, 2001.
[83]
D. Patterson, G. Gibson, and R. Katz. A case for
redundant arrays of inexpensive disks (RAID).
In Proceedings of the 1998 ACM SIGMOD
International Conference on Management of
Data, pages 109–116. ACM, June 1988.
[84]
L. Peterson and B. Davie. Computer Networks:
A Systems Approach, Fifth Edition. Morgan
Kaufmann, 2011.
[85]
J. Pincus and B. Baker. Beyond stack smashing:
Recent advances in exploiting buffer overruns.
IEEE Security and Privacy 2(4):20–27, 2004.
[86]
S. Przybylski. Cache and Memory Hierarchy
Design: A Performance-Directed Approach.
Morgan Kaufmann, 1990.
[87]
W. Pugh. The Omega test: A fast and practical
integer programming algorithm for depen-
