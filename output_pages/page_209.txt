208
Chapter 3
Machine-Level Representation of Programs
Aside
The ever-changing forms of generated code
In our presentation, we will show the code generated by a particular version of gcc with particular
settings of the command-line options. If you compile code on your own machine, chances are you will be
using a different compiler or a different version of gcc and hence will generate different code. The open-
source community supporting gcc keeps changing the code generator, attempting to generate more
efﬁcient code according to changing code guidelines provided by the microprocessor manufacturers.
Our goal in studying the examples shown in our presentation is to demonstrate how to examine
assembly code and map it back to the constructs found in high-level programming languages. You will
need to adapt these techniques to the style of code generated by your particular compiler.
this virtual address space, translating virtual addresses into the physical addresses
of values in the actual processor memory.
A single machine instruction performs only a very elementary operation. For
example, it might add two numbers stored in registers, transfer data between
memory and a register, or conditionally branch to a new instruction address. The
compiler must generate sequences of such instructions to implement program
constructs such as arithmetic expression evaluation, loops, or procedure calls and
returns.
3.2.2
Code Examples
Suppose we write a C code ﬁle mstore.c containing the following function deﬁ-
nition:
long mult2(long, long);
void multstore(long x, long y, long *dest) {
long t = mult2(x, y);
*dest = t;
}
To see the assembly code generated by the C compiler, we can use the -S
option on the command line:
linux> gcc -Og -S mstore.c
This will cause gcc to run the compiler, generating an assembly ﬁle mstore.s,
and go no further. (Normally it would then invoke the assembler to generate an
object-code ﬁle.)
The assembly-code ﬁle contains various declarations, including the following
set of lines:
multstore:
pushq
%rbx
