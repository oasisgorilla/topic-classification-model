364
Chapter 3
Machine-Level Representation of Programs
Instruction
Result
leaq 9(%rdx), %rax
9 + q
leaq (%rdx,%rbx), %rax
q + p
leaq (%rdx,%rbx,3), %rax
q + 3p
leaq 2(%rbx,%rbx,7), %rax
2 + 8p
leaq 0xE(,%rdx,3), %rax
14 + 3q
leaq 6(%rbx,%rdx,7), %rdx
6 + p + 7q
Solution to Problem 3.7 (page 229)
Again, reverse engineering proves to be a useful way to learn the relationship
between C code and the generated assembly code.
The best way to solve problems of this type is to annotate the lines of assembly
code with information about the operations being performed. Here is a sample:
short scale3(short x, short y, short z)
x in %rdi, y in %rsi, z in %rdx
scale3:
leaq
(%rsi,%rsi,9), %rbx
10 * y
leaq
(%rbx,%rdx), %rbx
10 * y + z
leaq
(%rbx,%rdi,%rsi), %rbx
10 * y + z + y * x
ret
From this, it is easy to generate the missing expression:
short t = 10 * y + z + y * x;
Solution to Problem 3.8 (page 230)
This problem gives you a chance to test your understanding of operands and the
arithmetic instructions. The instruction sequence is designed so that the result of
each instruction does not affect the behavior of subsequent ones.
Instruction
Destination
Value
addq %rcx,(%rax)
0x100
0x100
subq %rdx,8(%rax)
0x108
0xA8
imulq $16,(%rax,%rdx,8)
0x118
0x110
incq 16(%rax)
0x110
0x14
decq %rcx
%rcx
0x0
subq %rdx,%rax
%rax
0xFD
Solution to Problem 3.9 (page 231)
This exercise gives you a chance to generate a little bit of assembly code. The
solution code was generated by gcc. By loading parameter n in register %ecx, it
can then use byte register %cl to specify the shift amount for the sarq instruction.
It might seem odd to use a movl instruction, given that n is eight bytes long, but
keep in mind that only the least signiÔ¨Åcant byte is required to specify the shift
amount.
