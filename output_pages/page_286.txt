Section 3.7
Procedures
285
(a) Code for swap_add and calling function
long swap_add(long *xp, long *yp)
{
long x = *xp;
long y = *yp;
*xp = y;
*yp = x;
return x + y;
}
long caller()
{
long arg1 = 534;
long arg2 = 1057;
long sum = swap_add(&arg1, &arg2);
long diff = arg1 - arg2;
return sum * diff;
}
(b) Generated assembly code for calling function
long caller()
1
caller:
2
subq
$16, %rsp
Allocate 16 bytes for stack frame
3
movq
$534, (%rsp)
Store 534 in arg1
4
movq
$1057, 8(%rsp)
Store 1057 in arg2
5
leaq
8(%rsp), %rsi
Compute &arg2 as second argument
6
movq
%rsp, %rdi
Compute &arg1 as first argument
7
call
swap_add
Call swap_add(&arg1, &arg2)
8
movq
(%rsp), %rdx
Get arg1
9
subq
8(%rsp), %rdx
Compute diff = arg1 - arg2
10
imulq
%rdx, %rax
Compute sum * diff
11
addq
$16, %rsp
Deallocate stack frame
12
ret
Return
Figure 3.31
Example of procedure deﬁnition and call. The calling code must allocate
a stack frame due to the presence of address operators.
proc. This includes setting up the stack frame for the local variables and function
parameters, and for loading function arguments into registers. As Figure 3.33
shows, local variables x1–x4 are allocated on the stack and have different sizes.
Expressing their locations as offsets relative to the stack pointer, they occupy bytes
24–31 (x1), 20–23 (x2), 18–19 (x3), and 17 (s3). Pointers to these locations are
generated by leaq instructions (lines 7, 10, 12, and 14). Arguments 7 (with value
4) and 8 (a pointer to the location of x4) are stored on the stack at offsets 0 and 8
relative to the stack pointer.
