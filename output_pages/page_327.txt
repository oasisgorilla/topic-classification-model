326
Chapter 3
Machine-Level Representation of Programs
Some types of programs require the ability to dynamically generate and ex-
ecute code. For example, “just-in-time” compilation techniques dynamically gen-
erate code for programs written in interpreted languages, such as Java, to improve
execution performance. Whether or not the run-time system can restrict the ex-
ecutable code to just that part generated by the compiler in creating the original
program depends on the language and the operating system.
The techniques we have outlined—randomization, stack protection, and lim-
iting which portions of memory can hold executable code—are three of the most
common mechanisms used to minimize the vulnerability of programs to buffer
overﬂow attacks. They all have the properties that they require no special effort
on the part of the programmer and incur very little or no performance penalty.
Each separately reduces the level of vulnerability, and in combination they be-
come even more effective. Unfortunately, there are still ways to attack computers
[85, 97], and so worms and viruses continue to compromise the integrity of many
machines.
3.10.5
Supporting Variable-Size Stack Frames
We have examined the machine-level code for a variety of functions so far, but
they all have the property that the compiler can determine in advance the amount
of space that must be allocated for their stack frames. Some functions, however,
require a variable amount of local storage. This can occur, for example, when the
function calls alloca, a standard library function that can allocate an arbitrary
number of bytes of storage on the stack. It can also occur when the code declares
a local array of variable size.
Although the information presented in this section should rightfully be con-
sidered an aspect of how procedures are implemented, we have deferred the
presentation to this point, since it requires an understanding of arrays and align-
ment.
The code of Figure 3.43(a) gives an example of a function containing a
variable-size array. The function declares local array p of n pointers, where n is
given by the ﬁrst argument. This requires allocating 8n bytes on the stack, where
the value of n may vary from one call of the function to another. The compiler
therefore cannot determine how much space it must allocate for the function’s
stack frame. In addition, the program generates a reference to the address of local
variable i, and so this variable must also be stored on the stack. During execution,
the program must be able to access both local variable i and the elements of array
p. On returning, the function must deallocate the stack frame and set the stack
pointer to the position of the stored return address.
To manage a variable-size stack frame, x86-64 code uses register %rbp to serve
as a frame pointer (sometimes referred to as a base pointer, and hence the letters
bp in %rbp). When using a frame pointer, the stack frame is organized as shown
for the case of function vframe in Figure 3.44. We see that the code must save
the previous version of %rbp on the stack, since it is a callee-saved register. It then
keeps %rbp pointing to this position throughout the execution of the function, and
it references ﬁxed-length local variables, such as i, at offsets relative to %rbp.
