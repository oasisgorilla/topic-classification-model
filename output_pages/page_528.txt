Solutions to Practice Problems
527
to the rrmovq instruction. This would not be consistent with the convention for
handling popq %rsp determined in Practice Problem 4.8.
Solution to Problem 4.33 (page 488)
This problem lets you experience one of the important tasks in processor design—
devising test programs for a new processor. In general, we should have test pro-
grams that will exercise all of the different hazard possibilities and will generate
incorrect results if some dependency is not handled properly.
For this example, we can use a slightly modiﬁed version of the program shown
in Practice Problem 4.32:
1
irmovq $5, %rdx
2
irmovq $0x100,%rsp
3
rmmovq %rdx,0(%rsp)
4
popq %rsp
5
nop
6
nop
7
rrmovq %rsp,%rax
The two nop instructions will cause the popq instruction to be in the write-back
stage when the rrmovq instruction is in the decode stage. If the two forwarding
sources in the write-back stage are given the wrong priority, then register %rax
will be set to the incremented program counter rather than the value read from
memory.
Solution to Problem 4.34 (page 489)
This logic only needs to check the ﬁve forwarding sources:
word d_valB = [
d_srcB == e_dstE : e_valE;
# Forward valE from execute
d_srcB == M_dstM : m_valM;
# Forward valM from memory
d_srcB == M_dstE : M_valE;
# Forward valE from memory
d_srcB == W_dstM : W_valM;
# Forward valM from write back
d_srcB == W_dstE : W_valE;
# Forward valE from write back
1 : d_rvalB;
# Use value read from register file
];
Solution to Problem 4.35 (page 490)
This change would not handle the case where a conditional move fails to satisfy
the condition, and therefore sets the dstE value to RNONE. The resulting value could
get forwarded to the next instruction, even though the conditional transfer does
not occur.
1
irmovq $0x123,%rax
2
irmovq $0x321,%rdx
3
xorq %rcx,%rcx
# CC = 100
4
cmovne
%rax,%rdx
# Not transferred
5
addq %rdx,%rdx
# Should be 0x642
6
halt
