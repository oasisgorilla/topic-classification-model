472
Chapter 4
Processor Architecture
the execute stage. We will look at the detailed mechanisms for making the pipeline
stall and for injecting bubbles in Section 4.5.8.
In using stalling to handle data hazards, we effectively execute programs
prog2 and prog4 by dynamically generating the pipeline ﬂow seen for prog1 (Fig-
ure 4.43). Injecting one bubble for prog2 and three for prog4 has the same effect
as having three nop instructions between the second irmovq instruction and the
addq instruction. This mechanism can be implemented fairly easily (see Problem
4.53), but the resulting performance is not very good. There are numerous cases
in which one instruction updates a register and a closely following instruction uses
the same register. This will cause the pipeline to stall for up to three cycles, reduc-
ing the overall throughput signiﬁcantly.
Avoiding Data Hazards by Forwarding
Our design for PIPE−reads source operands from the register ﬁle in the decode
stage, but there can also be a pending write to one of these source registers in
the write-back stage. Rather than stalling until the write has completed, it can
simply pass the value that is about to be written to pipeline register E as the
source operand. Figure 4.49 shows this strategy with an expanded view of the
pipeline diagram for cycle 6 of prog2. The decode-stage logic detects that register
. . .
0x000: irmovq $10,%rdx
# prog2
# prog2
0x00a: irmovq  $3,%rax
0x014: nop
0x015: nop
0x016: addq %rdx,%rax
0x018: halt
srcA = %rdx
srcB = %rax
W_dstE = %rax
W_valE = 3
D
valA      R[%rdx] = 10
valB      W_valE = 3
W
Cycle 6
R[%rax]      3
F
1
2
3
4
5
6
7
8
9
10
F
D
E
M
W
F
D
E
M
W
F
D
E
M
W
D
E
M
W
F
D
E
M
W
F
D
E
M
W
Figure 4.49
Pipelined execution of prog2 using forwarding. In cycle 6, the decode-
stage logic detects the presence of a pending write to register %rax in the write-back
stage. It uses this value for source operand valB rather than the value read from the
register ﬁle.
