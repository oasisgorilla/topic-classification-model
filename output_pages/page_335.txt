334
Chapter 3
Machine-Level Representation of Programs
ﬁrst operand is read from memory or from a general-purpose register. For our
purposes, we can ignore the second operand, since its value only affects the upper
bytes of the result. The destination must be an XMM register. In common usage,
both the second source and the destination operands are identical, as in the
instruction
vcvtsi2sdq
%rax, %xmm1, %xmm1
This instruction reads a long integer from register %rax, converts it to data type
double, and stores the result in the lower bytes of XMM register %xmm1.
Finally, for converting between two different ﬂoating-point formats, current
versions of gcc generate code that requires separate documentation. Suppose
the low-order 4 bytes of %xmm0 hold a single-precision value; then it would seem
straightforward to use the instruction
vcvtss2sd
%xmm0, %xmm0, %xmm0
to convert this to a double-precision value and store the result in the lower 8 bytes
of register %xmm0. Instead, we ﬁnd the following code generated by gcc:
Conversion from single to double precision
1
vunpcklps
%xmm0, %xmm0, %xmm0
Replicate first vector element
2
vcvtps2pd
%xmm0, %xmm0
Convert two vector elements to double
The vunpcklps instruction is normally used to interleave the values in two
XMM registers and store them in a third. That is, if one source register contains
words [s3, s2, s1, s0] and the other contains words [d3, d2, d1, d0], then the value
of the destination register will be [s1, d1, s0, d0]. In the code above, we see the
same register being used for all three operands, and so if the original register
held values [x3, x2, x1, x0], then the instruction will update the register to hold
values [x1, x1, x0, x0]. The vcvtps2pd instruction expands the two low-order single-
precision values in the source XMM register to be the two double-precision values
in the destination XMM register. Applying this to the result of the preceding
vunpcklps instruction would give values [dx0, dx0], where dx0 is the result of
converting x to double precision. That is, the net effect of the two instructions is
to convert the original single-precision value in the low-order 4 bytes of %xmm0 to
double precision and store two copies of it in %xmm0. It is unclear why gcc generates
this code. There is neither beneﬁt nor need to have the value duplicated within
the XMM register.
Gcc generates similar code for converting from double precision to single
precision:
Conversion from double to single precision
1
vmovddup
%xmm0, %xmm0
Replicate first vector element
2
vcvtpd2psx
%xmm0, %xmm0
Convert two vector elements to single
