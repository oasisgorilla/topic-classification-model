Section 2.2
Integer Representations
105
12,345
−12,345
53,191
Weight
Bit
Value
Bit
Value
Bit
Value
1
1
1
1
1
1
1
2
0
0
1
2
1
2
4
0
0
1
4
1
4
8
1
8
0
0
0
0
16
1
16
0
0
0
0
32
1
32
0
0
0
0
64
0
0
1
64
1
64
128
0
0
1
128
1
128
256
0
0
1
256
1
256
512
0
0
1
512
1
512
1,024
0
0
1
1,024
1
1,024
2,048
0
0
1
2,048
1
2,048
4,096
1
4,096
0
0
0
0
8,192
1
8,192
0
0
0
0
16,384
0
0
1
16,384
1
16,384
±32,768
0
0
1
−32,768
1
32,768
Total
12,345
−12,345
53,191
Figure 2.15
Two’s-complement representations of 12,345 and −12,345, and
unsigned representation of 53,191. Note that the latter two have identical bit
representations.
When run on a big-endian machine, this code prints 30 39 and cf c7, indi-
cating that x has hexadecimal representation 0x3039, while mx has hexadeci-
mal representation 0xCFC7. Expanding these into binary, we get bit patterns
[0011000000111001] for x and [1100111111000111] for mx. As Figure 2.15 shows,
Equation 2.3 yields values 12,345 and −12,345 for these two bit patterns.
Practice Problem 2.18 (solution page 185)
In Chapter 3, we will look at listings generated by a disassembler, a program that
converts an executable program ﬁle back to a more readable ASCII form. These
ﬁles contain many hexadecimal numbers, typically representing values in two’s-
complement form. Being able to recognize these numbers and understand their
signiﬁcance (for example, whether they are negative or positive) is an important
skill.
For the lines labeled A–I (on the right) in the following listing, convert the
hexadecimal values (in 32-bit two’s-complement form) shown to the right of the
instruction names (sub, mov, and add) into their decimal equivalents:
