Section 12.5
Synchronizing Threads with Semaphores
1045
/* Global variables */
int readcnt;
/* Initially = 0 */
sem_t mutex, w; /* Both initially = 1 */
void reader(void)
{
while (1) {
P(&mutex);
readcnt++;
if (readcnt == 1) /* First in */
P(&w);
V(&mutex);
/* Critical section */
/* Reading happens
*/
P(&mutex);
readcnt--;
if (readcnt == 0) /* Last out */
V(&w);
V(&mutex);
}
}
void writer(void)
{
while (1) {
P(&w);
/* Critical section */
/* Writing happens
*/
V(&w);
}
}
Figure 12.26
Solution to the Ô¨Årst readers-writers problem. Favors readers over
writers.
In the concurrent server in Figure 12.14, we created a new thread for each
new client. A disadvantage of this approach is that we incur the nontrivial cost
of creating a new thread for each new client. A server based on prethreading
tries to reduce this overhead by using the producer-consumer model shown in
Figure 12.27. The server consists of a main thread and a set of worker threads.
The main thread repeatedly accepts connection requests from clients and places
