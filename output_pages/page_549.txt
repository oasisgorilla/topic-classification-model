548
Chapter 5
Optimizing Program Performance
deployed, however, it is entirely possible that the procedure could be applied to
strings of over one million characters. All of a sudden this benign piece of code
has become a major performance bottleneck. By contrast, the performance of
lower2 will be adequate for strings of arbitrary length. Stories abound of major
programming projects in which problems of this sort occur. Part of the job of a
competent programmer is to avoid ever introducing such asymptotic inefﬁciency.
Practice Problem 5.3 (solution page 609)
Consider the following functions:
long min(long x, long y) { return x < y ? x : y; }
long max(long x, long y) { return x < y ? y : x; }
void incr(long *xp, long v) { *xp += v; }
long square(long x) { return x*x; }
The following three code fragments call these functions:
A.
for (i = min(x, y); i < max(x, y); incr(&i, 1))
t += square(i);
B.
for (i = max(x, y) - 1; i >= min(x, y); incr(&i, -1))
t += square(i);
C.
long low = min(x, y);
long high = max(x, y);
for (i = low; i < high; incr(&i, 1))
t += square(i);
Assume x equals 10 and y equals 100. Fill in the following table indicating the
number of times each of the four functions is called in code fragments A–C:
Code
min
max
incr
square
A.
B.
C.
5.5
Reducing Procedure Calls
As we have seen, procedure calls can incur overhead and also block most forms of
program optimization. We can see in the code for combine2 (Figure 5.6) that get_
vec_element is called on every loop iteration to retrieve the next vector element.
This function checks the vector index i against the loop bounds with every vector
reference, a clear source of inefﬁciency. Bounds checking might be a useful feature
when dealing with arbitrary array accesses, but a simple analysis of the code for
combine2 shows that all references will be valid.
