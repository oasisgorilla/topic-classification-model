482
Chapter 4
Processor Architecture
A third subtlety arises because a pipelined processor updates different parts
of the system state in different stages. It is possible for an instruction following
one causing an exception to alter some part of the state before the excepting
instruction completes. For example, consider the following code sequence, in
which we assume that user programs are not allowed to access addresses at the
upper end of the 64-bit range:
1
irmovq $1,%rax
2
xorq %rsp,%rsp
# Set stack pointer to 0 and CC to 100
3
pushq %rax
# Attempt to write to 0xfffffffffffffff8
4
addq
%rax,%rax
# (Should not be executed) Would set CC to 000
The pushq instruction causes an address exception, because decrementing the
stack pointer causes it to wrap around to 0xfffffffffffffff8. This exception
is detected in the memory stage. On the same cycle, the addq instruction is in
the execute stage, and it will cause the condition codes to be set to new values.
This would violate our requirement that none of the instructions following the
excepting instruction should have had any effect on the system state.
In general, we can both correctly choose among the different exceptions and
avoid raising exceptions for instructions that are fetched due to mispredicted
branches by merging the exception-handling logic into the pipeline structure. That
is the motivation for us to include a status code stat in each of our pipeline registers
(Figures 4.41 and 4.52). If an instruction generates an exception at some stage in
its processing, the status ﬁeld is set to indicate the nature of the exception. The
exception status propagates through the pipeline with the rest of the information
for that instruction, until it reaches the write-back stage. At this point, the pipeline
control logic detects the occurrence of the exception and stops execution.
To avoid having any updating of the programmer-visible state by instructions
beyond the excepting instruction, the pipeline control logic must disable any
updating of the condition code register or the data memory when an instruction in
the memory or write-back stages has caused an exception. In the example program
above, the control logic will detect that the pushq in the memory stage has caused
an exception, and therefore the updating of the condition code register by the
addq instruction in the execute stage will be disabled.
Let us consider how this method of handling exceptions deals with the sub-
tleties we have mentioned. When an exception occurs in one or more stages of a
pipeline, the information is simply stored in the status ﬁelds of the pipeline reg-
isters. The event has no effect on the ﬂow of instructions in the pipeline until an
excepting instruction reaches the ﬁnal pipeline stage, except to disable any updat-
ing of the programmer-visible state (the condition code register and the memory)
by later instructions in the pipeline. Since instructions reach the write-back stage
in the same order as they would be executed in a nonpipelined processor, we are
guaranteed that the ﬁrst instruction encountering an exception will arrive ﬁrst in
the write-back stage, at which point program execution can stop and the status
code in pipeline register W can be recorded as the program status. If some in-
struction is fetched but later canceled, any exception status information about the
