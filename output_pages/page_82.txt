Section 2.1
Information Storage
81
1
#include <stdio.h>
2
3
typedef unsigned char *byte_pointer;
4
5
void show_bytes(byte_pointer start, size_t len) {
6
int i;
7
for (i = 0; i < len; i++)
8
printf(" %.2x", start[i]);
9
printf("\n");
10
}
11
12
void show_int(int x) {
13
show_bytes((byte_pointer) &x, sizeof(int));
14
}
15
16
void show_float(float x) {
17
show_bytes((byte_pointer) &x, sizeof(float));
18
}
19
20
void show_pointer(void *x) {
21
show_bytes((byte_pointer) &x, sizeof(void *));
22
}
Figure 2.4
Code to print the byte representation of program objects. This code
uses casting to circumvent the type system. Similar functions are easily deﬁned for other
data types.
Procedures show_int, show_float, and show_pointer demonstrate how to
use procedure show_bytes to print the byte representations of C program objects
of type int, float, and void *, respectively. Observe that they simply pass show_
bytes a pointer &x to their argument x, casting the pointer to be of type unsigned
char *. This cast indicates to the compiler that the program should consider the
pointer to be to a sequence of bytes rather than to an object of the original data
type. This pointer will then be to the lowest byte address occupied by the object.
These procedures use the C sizeof operator to determine the number of bytes
used by the object. In general, the expression sizeof(T ) returns the number of
bytes required to store an object of type T . Using sizeof rather than a ﬁxed value
is one step toward writing code that is portable across different machine types.
We ran the code shown in Figure 2.5 on several different machines, giving the
results shown in Figure 2.6. The following machines were used:
Linux 32
Intel IA32 processor running Linux.
Windows
Intel IA32 processor running Windows.
Sun
Sun Microsystems SPARC processor running Solaris. (These machines
are now produced by Oracle.)
Linux 64
Intel x86-64 processor running Linux.
