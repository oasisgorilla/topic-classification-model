Section 3.6
Control
237
both statements in C and instructions in machine code are executed sequentially,
in the order they appear in the program. The execution order of a set of machine-
code instructions can be altered with a jump instruction, indicating that control
should pass to some other part of the program, possibly contingent on the result
of some test. The compiler must generate instruction sequences that build upon
this low-level mechanism to implement the control constructs of C.
In our presentation, we ﬁrst cover the two ways of implementing conditional
operations. We then describe methods for presenting loops and switch state-
ments.
3.6.1
Condition Codes
In addition to the integer registers, the CPU maintains a set of single-bit condition
code registers describing attributes of the most recent arithmetic or logical oper-
ation. These registers can then be tested to perform conditional branches. These
condition codes are the most useful:
CF: Carry ﬂag. The most recent operation generated a carry out of the most
signiﬁcant bit. Used to detect overﬂow for unsigned operations.
ZF: Zero ﬂag. The most recent operation yielded zero.
SF: Sign ﬂag. The most recent operation yielded a negative value.
OF: Overﬂow ﬂag. The most recent operation caused a two’s-complement
overﬂow—either negative or positive.
For example, suppose we used one of the add instructions to perform the
equivalent of the C assignment t = a+b, where variables a, b, and t are integers.
Then the condition codes would be set according to the following C expressions:
CF
(unsigned) t < (unsigned) a
Unsigned overﬂow
ZF
(t == 0)
Zero
SF
(t < 0)
Negative
OF
(a < 0 == b < 0) && (t < 0 != a < 0)
Signed overﬂow
The leaq instruction does not alter any condition codes, since it is intended
to be used in address computations. Otherwise, all of the instructions listed in
Figure 3.10 cause the condition codes to be set. For the logical operations, such
as xor, the carry and overﬂow ﬂags are set to zero. For the shift operations, the
carry ﬂag is set to the last bit shifted out, while the overﬂow ﬂag is set to zero. For
reasons that we will not delve into, the inc and dec instructions set the overﬂow
and zero ﬂags, but they leave the carry ﬂag unchanged.
In addition to the setting of condition codes by the instructions of Figure 3.10,
there are two instruction classes (having 8-, 16-, 32-, and 64-bit forms) that set
condition codes without altering any other registers; these are listed in Figure 3.13.
The cmp instructions set the condition codes according to the differences of their
two operands. They behave in the same way as the sub instructions, except that
they set the condition codes without updating their destinations. With ATT format,
