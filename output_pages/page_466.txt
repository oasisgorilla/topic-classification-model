Section 4.5
Pipelined Y86-64 Implementations
465
Aside
Return address prediction with a stack
With most programs, it is very easy to predict return addresses, since procedure calls and returns occur
in matched pairs. Most of the time that a procedure is called, it returns to the instruction following the
call. This property is exploited in high-performance processors by including a hardware stack within
the instruction fetch unit that holds the return address generated by procedure call instructions. Every
time a procedure call instruction is executed, its return address is pushed onto the stack. When a return
instruction is fetched, the top value is popped from this stack and used as the predicted return address.
Like branch prediction, a mechanism must be provided to recover when the prediction was incorrect,
since there are times when calls and returns do not match. In general, the prediction is highly reliable.
This hardware stack is not part of the programmer-visible state.
results, since the return address will be whatever word is on the top of the stack.
In our design, we will not attempt to predict any value for the return address.
Instead, we will simply hold off processing any more instructions until the ret
instruction passes through the write-back stage. We will return to this part of the
implementation in Section 4.5.8.
The PIPE−fetch stage, diagrammed at the bottom of Figure 4.41, is respon-
sible for both predicting the next value of the PC and selecting the actual PC for
the instruction fetch. We can see the block labeled “Predict PC” can choose either
valP (as computed by the PC incrementer) or valC (from the fetched instruction).
This value is stored in pipeline register F as the predicted value of the program
counter. The block labeled “Select PC” is similar to the block labeled “PC” in the
SEQ+ PC selection stage (Figure 4.40). It chooses one of three values to serve as
the address for the instruction memory: the predicted PC, the value of valP for
a not-taken branch instruction that reaches pipeline register M (stored in regis-
ter M_valA), or the value of the return address when a ret instruction reaches
pipeline register W (stored in W_valM).
4.5.5
Pipeline Hazards
Our structure PIPE−is a good start at creating a pipelined Y86-64 processor.
Recall from our discussion in Section 4.4.4, however, that introducing pipelining
into a system with feedback can lead to problems when there are dependencies
between successive instructions. We must resolve this issue before we can com-
plete our design. These dependencies can take two forms: (1) data dependencies,
where the results computed by one instruction are used as the data for a follow-
ing instruction, and (2) control dependencies, where one instruction determines
the location of the following instruction, such as when executing a jump, call, or
return. When such dependencies have the potential to cause an erroneous com-
putation by the pipeline, they are called hazards. Like dependencies, hazards can
be classiﬁed as either data hazards or control hazards. We ﬁrst concern ourselves
with data hazards and then consider control hazards.
