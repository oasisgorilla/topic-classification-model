872
Chapter 9
Virtual Memory
physical copy of the object. For each process that maps the private object, the page
table entries for the corresponding private area are ﬂagged as read-only, and the
area struct is ﬂagged as private copy-on-write. So long as neither process attempts
to write to its respective private area, they continue to share a single copy of the
object in physical memory. However, as soon as a process attempts to write to
some page in the private area, the write triggers a protection fault.
When the fault handler notices that the protection exception was caused by
the process trying to write to a page in a private copy-on-write area, it creates a
new copy of the page in physical memory, updates the page table entry to point
to the new copy, and then restores write permissions to the page, as shown in
Figure 9.30(b). When the fault handler returns, the CPU re-executes the write,
which now proceeds normally on the newly created page.
By deferring the copying of the pages in private objects until the last possible
moment, copy-on-write makes the most efﬁcient use of scarce physical memory.
9.8.2
The fork Function Revisited
Now that we understand virtual memory and memory mapping, we can get a clear
idea of how the fork function creates a new process with its own independent
virtual address space.
When the fork function is called by the current process, the kernel creates
various data structures for the new process and assigns it a unique PID. To create
the virtual memory for the new process, it creates exact copies of the current
process’s mm_struct, area structs, and page tables. It ﬂags each page in both
processes as read-only, and ﬂags each area struct in both processes as private copy-
on-write.
When the fork returns in the new process, the new process now has an exact
copy of the virtual memory as it existed when the fork was called. When either
of the processes performs any subsequent writes, the copy-on-write mechanism
creates new pages, thus preserving the abstraction of a private address space for
each process.
9.8.3
The execve Function Revisited
Virtual memory and memory mapping also play key roles in the process of loading
programs into memory. Now that we understand these concepts, we can under-
stand how the execve function really loads and executes programs. Suppose that
the program running in the current process makes the following call:
execve("a.out", NULL, NULL);
As you learned in Chapter 8, the execve function loads and runs the program
contained in the executable object ﬁle a.out within the current process, effectively
replacing the current program with the a.out program. Loading and running
a.out requires the following steps:
