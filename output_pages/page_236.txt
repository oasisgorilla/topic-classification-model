Section 3.5
Arithmetic and Logical Operations
235
we rely on support provided by gcc for 128-bit integers, declared using the name
__int128. Our code uses a typedef declaration to deﬁne data type uint128_t,
following the naming pattern for other data types found in inttypes.h. The code
speciﬁes that the resulting product should be stored at the 16 bytes designated by
pointer dest.
The assembly code generated by gcc for this function is as follows:
void store_uprod(uint128_t *dest, uint64_t x, uint64_t y)
dest in %rdi, x in %rsi, y in %rdx
1
store_uprod:
2
movq
%rsi, %rax
Copy x to multiplicand
3
mulq
%rdx
Multiply by y
4
movq
%rax, (%rdi)
Store lower 8 bytes at dest
5
movq
%rdx, 8(%rdi)
Store upper 8 bytes at dest+8
6
ret
Observe that storing the product requires two movq instructions: one for the
low-order 8 bytes (line 4), and one for the high-order 8 bytes (line 5). Since the
code is generated for a little-endian machine, the high-order bytes are stored at
higher addresses, as indicated by the address speciﬁcation 8(%rdi).
Our earlier table of arithmetic operations (Figure 3.10) does not list any
division or modulus operations. These operations are provided by the single-
operand divide instructions similar to the single-operand multiply instructions.
The signed division instruction idivl takes as its dividend the 128-bit quantity
in registers %rdx (high-order 64 bits) and %rax (low-order 64 bits). The divisor is
given as the instruction operand. The instruction stores the quotient in register
%rax and the remainder in register %rdx.
For most applications of 64-bit addition, the dividend is given as a 64-bit value.
This value should be stored in register %rax. The bits of %rdx should then be set to
either all zeros (unsigned arithmetic) or the sign bit of %rax (signed arithmetic).
The latter operation can be performed using the instruction cqto.2 This instruction
takes no operands—it implicitly reads the sign bit from %rax and copies it across
all of %rdx.
As an illustration of the implementation of division with x86-64, the following
C function computes the quotient and remainder of two 64-bit, signed numbers:
void remdiv(long x, long y,
long *qp, long *rp) {
long q = x/y;
long r = x%y;
*qp = q;
*rp = r;
}
2. This instruction is called cqo in the Intel documentation, one of the few cases where the ATT-format
name for an instruction does not match the Intel name.
