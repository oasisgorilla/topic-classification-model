584
Chapter 5
Optimizing Program Performance
By using multiple optimizations, we have been able to achieve CPEs close to
the throughput bounds of 0.50 and 1.00, limited only by the capacities of the func-
tional units. These represent 10–20× improvements on the original code. This has
all been done using ordinary C code and a standard compiler. Rewriting the code
to take advantage of the newer SIMD instructions yields additional performance
gains of nearly 4× or 8×. For example, for single-precision multiplication, the CPE
drops from the original value of 11.14 down to 0.06, an overall performance gain
of over 180×. This example demonstrates that modern processors have consid-
erable amounts of computing power, but we may need to coax this power out of
them by writing our programs in very stylized ways.
5.11
Some Limiting Factors
We have seen that the critical path in a data-ﬂow graph representation of a
program indicates a fundamental lower bound on the time required to execute a
program. That is, if there is some chain of data dependencies in a program where
the sum of all of the latencies along that chain equals T , then the program will
require at least T cycles to execute.
We have also seen that the throughput bounds of the functional units also
impose a lower bound on the execution time for a program. That is, assume
that a program requires a total of N computations of some operation, that the
microprocessor has C functional units capable of performing that operation, and
that these units have an issue time of I. Then the program will require at least
N . I/C cycles to execute.
In this section, we will consider some other factors that limit the performance
of programs on actual machines.
5.11.1
Register Spilling
The beneﬁts of loop parallelism are limited by the ability to express the compu-
tation in assembly code. If a program has a degree of parallelism P that exceeds
the number of available registers, then the compiler will resort to spilling, stor-
ing some of the temporary values in memory, typically by allocating space on the
run-time stack. As an example, the following measurements compare the result
of extending the multiple accumulator scheme of combine6 to the cases of k = 10
and k = 20:
Integer
Floating point
Function
Page
Method
+
*
+
*
combine6
573
10 × 10 unrolling
0.55
1.00
1.01
0.52
20 × 20 unrolling
0.83
1.03
1.02
0.68
Throughput bound
0.50
1.00
1.00
0.50
