348
Chapter 3
Machine-Level Representation of Programs
1
store_prod:
2
movq
%rdx, %rax
3
cqto
4
movq
%rsi, %rcx
5
sarq
$63, %rcx
6
imulq
%rax, %rcx
7
imulq
%rsi, %rdx
8
addq
%rdx, %rcx
9
mulq
%rsi
10
addq
%rcx, %rdx
11
movq
%rax, (%rdi)
12
movq
%rdx, 8(%rdi)
13
ret
This code uses three multiplications for the multiprecision arithmetic required
to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used
to compute the product, and annotate the assembly code to show how it realizes
your algorithm. Hint: When extending arguments of x and y to 128 bits, they can
be rewritten as x = 264 . xh + xl and y = 264 . yh + yl, where xh, xl, yh, and yl are 64-
bit values. Similarly, the 128-bit product can be written as p = 264 . ph + pl, where
ph and pl are 64-bit values. Show how the code computes the values of ph and pl
in terms of xh, xl, yh, and yl.
3.60 ◆◆
Consider the following assembly code:
long loop(long x, int n)
x in %rdi, n in %esi
1
loop:
2
movl
%esi, %ecx
3
movl
$1, %edx
4
movl
$0, %eax
5
jmp
.L2
6
.L3:
7
movq
%rdi, %r8
8
andq
%rdx, %r8
9
orq
%r8, %rax
10
salq
%cl, %rdx
11
.L2:
12
testq
%rdx, %rdx
13
jne
.L3
14
rep; ret
The preceding code was generated by compiling C code that had the following
overall form:
